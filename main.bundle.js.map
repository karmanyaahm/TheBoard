{"version":3,"file":"main.bundle.js","mappings":"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","sources":["webpack://theboard_matrix/./src/helper.js","webpack://theboard_matrix/./src/drawing.js","webpack://theboard_matrix/./src/paper-canvas.js","webpack://theboard_matrix/./src/actions.js","webpack://theboard_matrix/./src/tools/line-style-selector.js","webpack://theboard_matrix/./src/color-picker.js","webpack://theboard_matrix/./src/tools/tool-pen.js","webpack://theboard_matrix/./src/input.js","webpack://theboard_matrix/./src/tools/tool-eraser.js","webpack://theboard_matrix/./src/tools/tool-line.js","webpack://theboard_matrix/./src/tools/tool-rect.js","webpack://theboard_matrix/./src/sturctures/notebook-tree.js","webpack://theboard_matrix/./src/components/login-container.js","webpack://theboard_matrix/./src/main.js","webpack://theboard_matrix/./src/backend/matrix.js","webpack://theboard_matrix/./src/sturctures/object-store.js","webpack://theboard_matrix/./src/tools/tool-wheel.js"],"sourcesContent":["export function parsePath(p_path, objpos) {\n    let arr = p_path.split(\" \");\n    var offset = objpos.split(\" \");\n    var returnval = [];\n    for (let i = 0; i < arr.length; i += 4) {\n        let time = parseFloat(arr[i]);\n        let x = parseFloat(arr[i + 1]) + parseFloat(offset[0]);\n        let y = parseFloat(arr[i + 2]) + parseFloat(offset[1]);\n        let lineWidth = parseFloat(arr[i + 3]);\n        returnval.push([time, x, y, lineWidth]);\n    }\n    return returnval;\n}\nexport function parseBezierPath(p_path, objpos) {\n    let arr = p_path.split(\" \");\n    arr = arr.filter((e)=>e!=\"\")\n    var offset = objpos.split(\" \");\n    var returnval = [];\n    for (let i = 0; i < arr.length; i += 6) {\n        let seg = new paper.Segment(\n            new paper.Point(parseFloat(arr[i + 0]) + parseFloat(offset[0]),\n                parseFloat(arr[i + 1]) + parseFloat(offset[1])),\n            new paper.Point(parseFloat(arr[i + 2]), parseFloat(arr[i + 3])),\n            new paper.Point(parseFloat(arr[i + 4]), parseFloat(arr[i + 5])))\n        // let time = parseFloat(arr[i]);\n        // let x = parseFloat(arr[i + 1]) + parseFloat(offset[0]);\n        // let y = parseFloat(arr[i + 2]) + parseFloat(offset[1]);\n        // let lineWidth = parseFloat(arr[i + 3]);\n        returnval.push(seg);\n    }\n    return returnval;\n}\nexport function mousePathToString(points) {\n    //format:\n    // time x y width\n    let mouse_path_string = \"\";\n    for (let p of points) {\n        mouse_path_string += p[0] + \" \" + p[1] + \" \" + p[2] + \" \" + p[3] + \" \";\n    }\n    return mouse_path_string;\n}\nexport function paperPathToString(path) {\n    //format:\n    // x y handleInX handleInY handleOutX handleOutY\n    let movedPath = path.clone();\n    let boundingRect = movedPath.bounds;\n    movedPath.position = movedPath.position.subtract(boundingRect.topLeft);\n    var precision = 3;\n    let paper_path_string = \"\";\n    for (let s of movedPath.segments) {\n        paper_path_string += s.point.x.toFixed(precision) + \" \" + s.point.y.toFixed(precision) + \" \" + s.handleIn.x.toFixed(precision) + \" \" + s.handleIn.y.toFixed(precision) + \" \" + s.handleOut.x.toFixed(precision) + \" \" + s.handleOut.y.toFixed(precision) + \" \";\n    }\n    movedPath.remove();\n    return [boundingRect.topLeft, boundingRect.size, paper_path_string.trim()];\n}\nexport function pathPosSizeCorrection(points) {\n    let posMin = [Number.MAX_VALUE, Number.MAX_VALUE];\n    let posMax = [-Number.MAX_VALUE, -Number.MAX_VALUE];\n    for (let p of points) {\n        posMin[0] = Math.min(posMin[0], p[1]);\n        posMin[1] = Math.min(posMin[1], p[2]);\n        posMax[0] = Math.max(posMax[0], p[1]);\n        posMax[1] = Math.max(posMax[1], p[2]);\n    }\n    let correctedPoints = points.map((p) => { return [p[0], p[1] - posMin[0], p[2] - posMin[1], p[3]] });\n    let width = posMax[0] - posMin[0];\n    let height = posMax[1] - posMin[1];\n    // path pos size\n    return [correctedPoints, posMin, [width, height]];\n}\nexport function paperPathPosSizeCorrection(path) {\n    let points = [];\n    for (let s of segments) {\n        points.push([0, s.point.x, s.point.y, path.strokeWidth]);\n    }\n\n}\n// export function pathChunkPosCorrection(chunk, points) {\n//     return points.map((p) => { return [p[0], p[1] - chunk[0], p[2] - chunk[1], p[3]] });\n// }\nexport function dist(p, q) {\n    return Math.sqrt((p.x - q.x) ** 2 + (p.y - q.y) ** 2);\n}\nexport function parsePoint(string) {\n    let arr = (string || \"0 0\").split(\" \");\n    return new paper.Point(parseFloat(arr[0]), parseFloat(arr[1]));\n}\n\nexport function setAlpha(color, opacity) {\n    // coerce values so ti is between 0 and 1.\n    const _opacity = Math.round(Math.min(Math.max(opacity || 1, 0), 1) * 255);\n    const _opStr = _opacity.toString(16).toUpperCase();\n    if (color.length == 7) {\n        return color + _opStr;\n    } else if (color.length == 9) {\n        color[7] = _opStr[0];\n        color[8] = _opStr[1];\n        return color;\n    }\n}","// var cache_canvas = document.createElement('canvas');\n// cache_canvas.width = 3000;\n// cache_canvas.height = 8000;\n// var cache_ctx = cache_canvas.getContext(\"2d\");\n// var cache_canvas = new UnlimitedCanvas();\n// import { drawingCanvas } from './main';\nimport { parsePath, parseBezierPath, parsePoint } from './helper';\n\n// var setting_grid = \"\";\n// var display_canvas;\n// var display_ctx;\n\nexport function drawEvent(event, animated, updateDisplay_DEPRECATED = true) {\n    let drawC = appData.drawingCanvas;\n    if (event.content.objtype == \"p.path\") {\n        \n        if (event.content.version == 1 || !(\"version\" in event.content)){\n            let points = parsePath(event.content.path, event.content.objpos);\n            let pos = parsePoint(event.content.objpos);\n            let size = parsePoint(event.content.objsize);\n            let color = \"objcolor\" in event.content ? event.content.objcolor : \"#000\"\n            // let strokeWidth = parseFloat(event.content.strokeWidth);\n            if (animated) {\n                drawC.asyncAddPathV1([pos.x,pos.y], points, color);\n            } else {\n                drawC.drawBoundingBox([[pos.x,pos.y], size]);\n                drawC.addPathV1(points, color, [[pos.x,pos.y], size], event.event_id);\n                if (updateDisplay_DEPRECATED) { drawC.updateDisplay_DEPRECATED(true); }\n            }\n        }\n        \n        else if (event.content.version == 2){\n            let segments = parseBezierPath(event.content.path, event.content.objpos);\n            // let pos = parsePoint(event.content.objpos);\n            // let size = parsePoint(event.content.objsize);\n            let strokeWidth = parseFloat(event.content.strokeWidth);\n            let closed = (\"closed\" in event.content && event.content.closed)\n            let color = \"objcolor\" in event.content ? event.content.objcolor : \"#000\"\n            let fillColor = \"objFillColor\" in event.content ? event.content.objFillColor : \"#00000000\"\n            \n            if (animated) {\n                drawC.updateDisplay_DEPRECATED(true);\n                drawC.asyncAddPathV2(segments, color,fillColor, strokeWidth, closed, event.event_id);\n            } else {\n                // drawC.drawBoundingBox([pos, size]);\n                drawC.addPathV2(segments, color,fillColor, strokeWidth, closed, event.event_id);\n                if (updateDisplay_DEPRECATED) { drawC.updateDisplay_DEPRECATED(true); }\n            }\n        }\n    }\n}\n\nconst sleep = ms => {\n    return new Promise(resolve => setTimeout(resolve, ms))\n}\n\nfunction drawGrid(ctx, grid, size, gridsize, color) {\n    ctx.fillStyle = color;\n    ctx.strokeStyle = color;\n    ctx.lineWidth = 2;\n    if (grid === \"dots\") {\n        let radius = 3;\n        let xcount = size[0] / gridsize;\n        let ycount = size[1] / gridsize;\n        ctx.beginPath();\n        for (let i = 0; i < xcount; i++) {\n            for (let j = 0; j < ycount; j++) {\n                ctx.moveTo(i * gridsize, j * gridsize);\n                ctx.ellipse(i * gridsize, j * gridsize, radius, radius, 0, 0, Math.PI * 2);\n            }\n        }\n        ctx.fill();\n    }\n    if (grid === \"squares\") {\n        let xcount = size[0] / gridsize;\n        let ycount = size[1] / gridsize;\n        ctx.beginPath();\n        for (let i = 0; i < xcount; i++) {\n            ctx.moveTo(i * gridsize, 0);\n            ctx.lineTo(i * gridsize, size[1]);\n        }\n        for (let j = 0; j < ycount; j++) {\n            ctx.moveTo(0, j * gridsize);\n            ctx.lineTo(size[0], j * gridsize);\n        }\n        ctx.stroke();\n    }\n}\n\nexport function reloadCacheCanvas(animated = false) {\n    appData.drawingCanvas.reload();\n}\n// function reloadCacheCanvas(animated = false) {\n//     cache_ctx.fillStyle = \"#eee\";\n//     cache_ctx.fillRect(0, 0, cache_canvas.width, cache_canvas.height);\n//     cache_ctx.clearRect(3, 3, cache_canvas.width - 6, cache_canvas.height - 6);\n//     drawGrid(cache_ctx, setting_grid, [cache_canvas.width, cache_canvas.height], 50, cache_ctx.fillStyle)\n//     console.log(\"!! Cache Canvas redraw START\");\n//     let starttime = Date.now()\n//     objectStore.allSorted().forEach(obj => {\n//         if (obj.type == \"p.whiteboard.object\") {\n//             drawEvent(obj, animated, animated, DRAW_BOUNDING_BOX);\n//         }\n//     });\n//     console.log(\"!! Cache Canvas redraw DONE in\", Date.now() - starttime);\n// }\n\n\n\n\n// function updateDisplay_DEPRECATEDCanvas(clear = true) {\n//     const canvas = document.getElementById(\"canvas\");\n//     const ctx = canvas.getContext(\"2d\");\n//     if (clear) {\n//         ctx.save();\n//         ctx.setTransform(1, 0, 0, 1, 0, 0);\n//         ctx.clearRect(0, 0, canvas.width, canvas.height);\n//         ctx.restore();\n//     }\n//     ctx.drawImage(cache_canvas, 0, 0);\n// }\n\n// OLD!!\n// function reloadCanvas(animated = false) {\n//     const canvas = document.getElementById(\"canvas\");\n//     const ctx = canvas.getContext(\"2d\");\n//     ctx.clearRect(0, 0, canvas.width, canvas.height);\n//     objectStore.all().forEach(obj => {\n//         if (obj.type == \"p.whiteboard.object\") {\n//             console.log(obj.type);\n//             drawEvent(obj, canvasOffset, animated);\n//         }\n//     });\n// }\n\n// only for button...\n// function clearDisplayCanvas() {\n//     const canvas = document.getElementById(\"canvas\");\n//     const ctx = canvas.getContext(\"2d\");\n//     ctx.clearRect(0, 0, canvas.width, canvas.height);\n// }\n","// import { objectStore } from './main';\nimport { drawEvent } from './drawing';\nexport const paper = require('paper');\nexport default class PaperCanvas {\n    constructor() {\n        this.css_id = \"paper-canvas\";\n        this.displayPaths = [];\n        this.toolLayer = null\n        this.drawLayer = null;\n        this.canvas = null;\n    }\n    activateToolLayer() {\n        this.toolLayer.activate()\n    }\n    activateDrawLayer() {\n        this.drawLayer.activate();\n    }\n    init() {\n        // Get a reference to the canvas object\n        this.canvas = document.getElementById('paper-canvas');\n        // Create an empty project and a view for the canvas:\n        paper.setup(this.canvas);\n        paper.install(window)\n        this.drawLayer = paper.project.activeLayer;\n        this.toolLayer = new paper.Layer()\n    }\n    offset(offset_delta) {\n        paper.view.center = paper.view.center.subtract(offset_delta);\n    }\n    resetOffset() {\n        this.setOffset(new paper.Point(0, 0));\n    }\n    setOffset(offset) {\n        paper.view.center = offset;\n    }\n    getZoom() {\n        return paper.view.zoom;\n    }\n    zoom(factor, zoomOrigin) {\n        if (zoomOrigin === null) {\n            paper.view.scale(factor)\n        } else {\n            var zoomOriProj = paper.view.viewToProject(zoomOrigin);\n            paper.view.scale(factor, zoomOriProj);\n        }\n    }\n    setZoom(zoom, zoomOrigin = paper.view.center) {\n        var currentViewCenter = paper.view.center;\n        var zoomOriProj = paper.view.viewToProject(zoomOrigin);\n        paper.view.center = zoomOriProj;\n        var scale = paper.view.zoom;\n        paper.view.zoom = zoom;\n        paper.view.center = currentViewCenter;\n    }\n    resetZoom() {\n        this.setZoom(1);\n    }\n    asyncAddPathV1() {\n        console.log(\"WAIT WHAT???\")\n    }\n    asyncAddPathV2(segments, color, fillColor, strokeWidth, closed = false, id = \"\") {\n        // TODO make async animation using dash\n        let p = this.addPathV2(segments, color, fillColor, strokeWidth, closed, id);\n        let length = 0;\n        length = p.length;\n        p.dashArray = [length, length];\n        // TODO dont hardcode the speed. instead get it from the event\n        // \"drawSpeed\": \"20 50 50 20 12\"\n        // 20ms for the first 50 px length, 50 ms for the second px length...\n        p.tween({ dashOffset: length }, { dashOffset: 0 }, 2 * length).then(() => {\n            p.dashArray = []\n        })\n        // p.tween({ dashArray: [10, 10] }, { dashArray: [1000, 10] }, 3000);\n    }\n\n    addPathV2(segments, color, fillColor, strokeWidth, closed = false, id = \"\") {\n        var p = new paper.Path(segments);\n        p.strokeColor = color;\n        // if (fillColor != \"#00000000\") { p.fillColor = fillColor; }\n        p.fillColor = fillColor;\n\n        p.strokeWidth = strokeWidth;\n        p.strokeCap = \"round\";\n        p.closed = closed;\n        if (id != \"\") {\n            p.data.id = id\n        }\n        return p;\n        // p.moveTo(new paper.Point(points[0][1], points[0][2]));\n        // for (let i = 1; i < points.length; i++) {\n        //     p.lineTo(new paper.Point(points[i][1], points[i][2]));\n        // }\n    }\n    addPathV1(points, color, [pos, size], id = \"\") {\n        var p = new paper.Path();\n        p.strokeColor = color;\n        p.strokeWidth = 2;\n        p.strokeCap = \"round\";\n        if (id != \"\") {\n            p.data.id = id\n        }\n        p.moveTo(new paper.Point(points[0][1], points[0][2]));\n        for (let i = 1; i < points.length; i++) {\n            p.lineTo(new paper.Point(points[i][1], points[i][2]));\n        }\n    }\n    updateDisplay_DEPRECATED() {\n        if (this.dispPath !== null) {\n            // this.dispPath.remove();\n            this.displayPaths.push(this.dispPath);\n            this.dispPath = null;\n        }\n        // for(p of this.displayPaths){\n        //     p.remove();\n        // }\n    }\n    // TODO call this function in a moment where ne drawing animaiotn is running\n    clearDisplayPaths() {\n        this.displayPaths.forEach((p) => { p.remove() });\n    }\n    clear() {\n        var length = 0;// = paper.project.activeLayer.removeChildren();\n        for (let l of paper.project.layers) {\n            if(l === this.toolLayer){\n                continue\n            }\n            length += l.removeChildren().length;\n        }\n        console.log(\"removed \", length, \" items\")\n    }\n    drawBoundingBox(box) {\n        // console.log(\"drawBoundingBox not implemented for paper-canvas\")\n    }\n    reload(animated = false) {\n        this.clear();\n        var starttime = Date.now();\n        console.log(\"!! Paper Canvas redraw START\");\n        appData.objectStore.allSorted().forEach(obj => {\n            if (obj.type == \"p.whiteboard.object\") {\n                drawEvent(obj, animated, animated);\n            }\n        });\n        console.log(\"!! Paper Canvas redraw DONE in\", Date.now() - starttime);\n    }\n    getTransformedPointer(x, y) {\n        return paper.view.viewToProject(new paper.Point(x, y))\n    }\n}","import { login, updateAddRoomList } from './main'\n// import { matrixClient } from './main'//backend;\nimport { parsePoint } from './helper'\n\n\nwindow.actions = {\n    // loginClicked: loginClicked,\n    redactLastAction: redactLastAction,\n    formSubmit: formSubmit,\n    replaceLastEvent: replaceLastEvent,\n    moveLastEvent: moveLastEvent,\n    showAddRoomMenu: showAddRoomMenu,\n    hideAddRoomMenu: hideAddRoomMenu,\n    showSettingsMenu: showSettingsMenu,\n    hideSettingsMenu: hideSettingsMenu,\n}\nfunction sendmsgs(amount, client, room) {\n    for (let i = 0; i < amount; i++) {\n        const content = {\n            \"body\": i + \" Test Message\",\n            \"msgtype\": \"m.text\"\n        };\n        client.sendEvent(room, \"m.room.message\", content, \"\", (err, res) => {\n            console.log(err);\n        });\n    }\n}\nfunction toggleGrid() {\n    console.log(setting_grid);\n    if (setting_grid === \"\") {\n        setting_grid = \"squares\";\n    }\n    else if (setting_grid === \"squares\") {\n        setting_grid = \"dots\";\n    }\n    else if (setting_grid === \"dots\") {\n        setting_grid = \"\";\n    }\n    reloadCacheCanvas();\n    appData.drawingCanvas.updateDisplay_DEPRECATED();\n}\nfunction toggleTool() {\n    if (tool.type === toolType.draw) {\n        tool.type = toolType.erase;\n    }\n    else if (tool.type === toolType.erase) {\n        tool.type = toolType.draw;\n    }\n    // else if (tool === \"mouse\"){\n    //     tool = \"draw\";\n    // }\n    document.getElementById(\"tool\").innerText = \"Tool: \" + tool.getString();\n}\nfunction redactLastAction() {\n    let id = \"\";\n    let roomId = appData.matrixClient.currentRoomId;\n    let userId = appData.matrixClient.client.getUserId();\n    let sortedEvents = objectStore.allSorted();\n    for (let i = sortedEvents.length - 1; (id === \"\" && i >= 0); i--) {\n        let event = sortedEvents[i];\n        console.log(\"looping through events to find the one to redact\");\n        if (event.type == \"p.whiteboard.object\" && event.sender == userId) {\n            id = event.event_id;\n            break;\n        }\n    }\n    client.redactEvent(roomId, id).then(t => {\n        console.log(\"redacted: \", t);\n    });\n}\nfunction sendRandomText(client, room) {\n    textList = [\"hallo du\", \"noch nen test string\", \"affe\", \"haus is gross\", \"wie gehts\"];\n    text = textList[Math.floor(Math.random() * textList.length)];\n    const content = {\n        \"body\": text,\n        \"msgtype\": \"m.text\"\n    };\n    client.sendEvent(room, \"m.room.message\", content, \"\", (err, res) => {\n        console.log(err);\n    });\n}\nfunction sendCustomEvent(client, room) {\n    console.log(\"try to send custom event: ...\")\n    const content = {\n        \"version\": 2,\n        \"svg\": \"none\",\n        \"objtype\": \"p.path\",\n        \"objpos\": \"100 100\",\n        \"objcolor\": \"#000\",\n        \"closed\": true,\n        \"objFillColor\": '#ff000030',\n        \"strokeWidth\": 3,\n        \"path\": \"0 0 0 0 0 0 0 100 0 20 0 0 100 100 0 0 0 0 0 100 0 0 0 0 \",\n    };\n    client.sendEvent(room, \"p.whiteboard.object\", content, \"\", (err, res) => {\n        console.log(err);\n    });\n}\nexport function sendPath(client, room, string_path, color, fillColor, offset, size, strokeWidth, closed, version) {\n    console.log(\"send random path: ...\")\n    const content = {\n        \"version\": version,\n        \"svg\": \"none\",\n        \"objtype\": \"p.path\",\n        \"objpos\": offset[0] + \" \" + offset[1],\n        \"objsize\": size[0] + \" \" + size[1],\n        \"objcolor\": color == \"\" ? \"#\" + [\"F55\", \"5F5\", \"55F\"][Math.floor(Math.random() * 3)] : color,\n        \"objFillColor\": fillColor == \"\" ? \"#\" + [\"F55\", \"5F5\", \"55F\"][Math.floor(Math.random() * 3)] : fillColor,\n        \"path\": string_path,\n        \"strokeWidth\": strokeWidth,\n        \"closed\": closed,\n    };\n    client.sendEvent(room, \"p.whiteboard.object\", content, \"\", (err, res) => {\n        console.log(err);\n    });\n}\nfunction sendRandomPath(client, room) {\n    console.log(\"send random path: ...\")\n\n    const content = {\n        \"svg\": \"none\",\n        \"objtype\": \"p.path\",\n        \"objpos\": Math.floor(Math.random() * 80) + \" \" + Math.floor(Math.random() * 80),\n        \"objcolor\": \"#\" + [\"F55\", \"5F5\", \"55F\"][Math.floor(Math.random() * 3)],\n        \"path\": randomPath(),\n    };\n    client.sendEvent(room, \"p.whiteboard.object\", content, \"\", (err, res) => {\n        console.log(err);\n    });\n}\nfunction sendRandomWalk(client, room) {\n    console.log(\"send random path: ...\")\n\n    const content = {\n        \"svg\": \"none\",\n        \"objtype\": \"p.path\",\n        \"objpos\": Math.floor(100 + Math.random() * 80) + \" \" + Math.floor(100 + Math.random() * 80),\n        \"objcolor\": \"#\" + [\"F55\", \"5F5\", \"55F\"][Math.floor(Math.random() * 3)],\n        \"path\": randomStroke(),\n    };\n    client.sendEvent(room, \"p.whiteboard.object\", content, \"\", (err, res) => {\n        console.log(err);\n    });\n}\nfunction randomPath() {\n    var path = \"\"\n    for (let i = 0; i < Math.floor(Math.random() * 50); i++) {\n        path += i * 0.1 + \" \" + Math.floor(Math.random() * 40) + \" \" + Math.floor(Math.random() * 40) + \" \" + Math.floor(Math.random() * 6) + \" \"\n    }\n    return path;\n}\nfunction randomWalk() {\n    var walk = \"\";\n    var width = 0.1;\n    var len = Math.floor(Math.random() * 50);\n    var pos = [0, 0];\n    for (let i = 0; i < len; i++) {\n        var widthdiff = Math.random() * 0.2;\n        width += Math.min(i < len / 2 ? widthdiff : -widthdiff, 3)\n        pos = [pos[0] + Math.random() * 5 - 2.5, pos[1] + Math.random() * 5 - 2.5]\n        walk += i * 0.1 + \" \" + pos[0] + \" \" + pos[1] + \" \" + width + \" \";\n    }\n    return walk;\n}\nfunction randomStroke() {\n    var walk = \"\";\n    var width = 0.1;\n    var len = Math.floor(Math.random() * 200) + 80;\n    var pos = [0, 0];\n    var angle = 0;\n    var v_a = 0.2\n    for (let i = 0; i < len; i++) {\n        angle += v_a + 3 * Math.random() * v_a;\n        if (Math.random() < 0.07) {\n            v_a = -v_a;\n        }\n        var widthdiff = 0.1;\n        width += (i > (len - 20) || i < 20) ? -widthdiff * Math.sign(i - len / 2) : 0;\n        // width = Math.sign(width) * Math.min(Math.abs(width),8);\n        stepdist = 4 + Math.random() * 5;\n        console.log(width)\n        pos = [pos[0] + stepdist * Math.sin(angle), pos[1] + stepdist * Math.cos(angle)];\n        walk += i * 0.1 + \" \" + pos[0] + \" \" + pos[1] + \" \" + width + \" \";\n    }\n    return walk;\n}\n\nfunction formSubmit(e) {\n    e.preventDefault();\n    console.log('onsub');\n    return false;\n}\n\n// function replaceLastEvent(matrixClient, currentRoomId) {\n//     let id = \"\";\n//     // let room = client.getRoom(roomId);\n//     let userId = matrixClient.getUserId();\n//     let sortedEvents = objectStore.allSorted();\n//     for (i = sortedEvents.length - 1; (id === \"\" && i >= 0); i--) {\n//         let event = sortedEvents[i];\n//         console.log(\"looping through events to find the one to redact\");\n//         if (event.type == \"p.whiteboard.object\" && event.sender == userId) {\n//             id = event.event_id;\n//             break;\n//         }\n//     }\n//     let replaceId = id;\n//     const content = {\n//         \"version\": 2,\n//         \"svg\": \"none\",\n//         \"objtype\": \"p.path\",\n//         \"objpos\": \"100 100\",\n//         \"objcolor\": \"#000\",\n//         \"closed\": true,\n//         \"objFillColor\": '#ff000030',\n//         \"strokeWidth\": 3,\n//         \"path\": \"0 0 0 0 0 0 0 100 0 0 0 0 100 100 0 0 0 0 100 0 0 0 0 0\",\n//     };\n//     // const replaceContent = {\n//     //     \"body\": \"\",\n//     //     \"m.new_content\": content,\n//     //     \"m.relates_to\": {\n//     //         \"rel_type\": \"m.replace\",\n//     //         \"event_id\": replaceId\n//     //     }\n//     // }\n//     matrixClient.sendEvent(currentRoomId, \"p.whiteboard.object\", content, \"\", (err, res) => {\n//         console.log(err);\n//     });\n//     matrixClient.redactEvent(currentRoomId, replaceId).then(t => {\n//         console.log(\"redacted for replace \", t);\n//     });\n// }\nfunction lastEvent() {\n    let lastEvent = null;\n    // let room = client.getRoom(roomId);\n    let userId = appData.matrixClient.client.getUserId();\n    let sortedEvents = appData.objectStore.allSorted();\n    for (let i = sortedEvents.length - 1; i >= 0; i--) {\n        let event = sortedEvents[i];\n        console.log(\"looping through events to find the one to redact\");\n        if (event.type == \"p.whiteboard.object\" && event.sender == userId) {\n            lastEvent = event;\n            break;\n        }\n    }\n    return lastEvent;\n}\nfunction replaceEvent(idToReplace, newContent) {\n    appData.matrixClient.client.sendEvent(appData.matrixClient.currentRoomId, \"p.whiteboard.object\", newContent, \"\", (err, res) => {\n        console.log(err);\n    });\n    appData.matrixClient.client.redactEvent(appData.matrixClient.currentRoomId, idToReplace).then(t => {\n        console.log(\"redacted for replace \", t);\n    });\n}\nfunction replaceLastEvent() {\n    let replaceId = lastEvent().event_id;\n    const content = {\n        \"version\": 2,\n        \"svg\": \"none\",\n        \"objtype\": \"p.path\",\n        \"objpos\": \"100 100\",\n        \"objcolor\": \"#000\",\n        \"closed\": true,\n        \"objFillColor\": '#ff000030',\n        \"strokeWidth\": 3,\n        \"path\": \"0 0 0 0 0 0 0 100 0 0 0 0 100 100 0 0 0 0 100 0 0 0 0 0\",\n    };\n    replaceEvent(replaceId, content);\n}\nfunction moveLastEvent() {\n    let ev = lastEvent();\n    let newPoint = parsePoint(ev.content.objpos).add(new paper.Point(100, 0));\n    ev.content.objpos = newPoint.x + \" \" + newPoint.y;\n    replaceEvent(ev.event_id, ev.content)\n}\nfunction toggleLeftBar() {\n    let body = document.getElementById('leftbar-expand');\n    let footer = document.getElementById('leftbar-footer')\n    if (body.getBoundingClientRect().height == 0) {\n        body.style.height = '20em';\n        footer.innerHTML = '˄'\n    } else {\n        body.style.height = '0';\n        footer.innerHTML = '˅'\n    }\n}\nfunction showAddRoomMenu() {\n    updateAddRoomList()\n    let addRoomMenu = document.getElementById(\"add-room-container\")\n    addRoomMenu.style.display = 'block'\n\n}\nfunction hideAddRoomMenu() {\n    let addRoomMenu = document.getElementById(\"add-room-container\")\n    addRoomMenu.style.display = 'none'\n}\n\nfunction showSettingsMenu() {\n    let settingsMenu = document.getElementById(\"settings-container\")\n    let roomId = document.getElementById('room-menu-room-id')\n    let room = appData.matrixClient.client.getRoom(appData.matrixClient.currentRoomId);\n\n    roomId.innerHTML = room.roomId\n    settingsMenu.style.display = 'block'\n}\nfunction hideSettingsMenu() {\n    let settingsMenu = document.getElementById(\"settings-container\")\n    settingsMenu.style.display = 'none'\n}","var _tool_stroke_width_index = 1\nvar TOOL_STROKE_WIDTH_OPTION_COUNT = 4\nexport default function init_line_style_selector(){\n    let button = document.getElementById(\"line-type-selector-button\")\n    button.onclick = function (btnEv) {\n        _tool_stroke_width_index += 1;\n        _tool_stroke_width_index = _tool_stroke_width_index % TOOL_STROKE_WIDTH_OPTION_COUNT\n        updateVisiblePreviewItem()\n    }\n    function updateVisiblePreviewItem() {\n        let previewItems = document.querySelectorAll(\"#line-type-selector-button div\");\n        for (let i = 0; i < TOOL_STROKE_WIDTH_OPTION_COUNT; i++) {\n            if (i == _tool_stroke_width_index) {\n                previewItems[i].style.display = \"block\"\n            } else {\n                previewItems[i].style.display = \"none\"\n            }\n        }\n    }\n    updateVisiblePreviewItem(1);\n}\nexport function GetToolStrokeWidthIndex() {\n    return _tool_stroke_width_index;\n}","// TODO: think about this appraoch... maybe store the color picker instance in main...\n// const paper = require('paper')\nimport {paper} from './paper-canvas'\n\nlet colorPickerSvg;\nexport function init_color_picker() {\n    colorPickerSvg = new ColorPicker();\n    colorPickerSvg.selectColor([1, 0])\n}\nexport function GetPickerColor(){\n    return colorPickerSvg.getColor().toCSS(true)\n}\nexport function SetColorPalette(palette){\n    colorPickerSvg.setColorPalette(palette)\n}\nexport class ColorPicker {\n\n    constructor() {\n        // this.colors = [\"#999\", \"#FEB326\", \"#7F58AF\"]//,\"#8ae234\"\n        // this.colors = [\"#999\", \"#64C5EB\", \"#8ae234\", \"#E84D8A\", \"#FEB326\", \"#7F58AF\"]//,\n        this.colors = [\"#999\",  \"#8ae234\", \"#ef2929\", \"#fcaf3e\", \"#729fcf\",\"#ad7fa8\"]//,\n        this.darkColors = this.colors.map((c) => { return new paper.Color(c).multiply(0.7) });\n        this.darkColors[0] = 'black'\n        this.outline = null;\n        this.colorPaths = [[], []]\n        this.selectedColor = [0, 0];\n        this.COLOR_PICKER_BORDER = 20;\n        this.innerCircle = 0.35\n        this.middleCircle = 0.7\n\n        this.project = new paper.Project(\"color-picker-canvas\");\n        this.redraw();\n    }\n    redraw(){\n        this.project.activate();\n        let el = document.getElementById('color-picker-canvas');\n        let size = paper.view.size;\n        let cent = new paper.Point(size.divide(2));\n        let radi = size.width / 2 - this.COLOR_PICKER_BORDER;\n        let circleBg = new paper.Path.Circle(cent, radi);\n        circleBg.shadowBlur = this.COLOR_PICKER_BORDER;\n        circleBg.shadowColor = 'grey';\n        circleBg.fillColor = 'white';\n        this.colorPaths[0] = this.create_segment_ring(this.colors, cent, radi * this.middleCircle - 1, radi, 0);\n        this.colorPaths[1] = this.create_segment_ring(this.darkColors, cent, radi * this.innerCircle, radi * this.middleCircle, 1);\n\n        let circleInner = new paper.Path.Circle(cent, this.innerCircle * radi);\n        circleInner.shadowBlur = this.COLOR_PICKER_BORDER;\n        circleInner.shadowColor = '#444';\n        circleInner.fillColor = 'white';\n\n        paper.projects[0].activate();\n    }\n    setColorPalette(palette){\n        this.colors = [\"#999\"].concat(palette);\n        this.darkColors = this.colors.map((c) => { return new paper.Color(c).multiply(0.7) });\n        this.darkColors[0] = 'black'\n        this.redraw()\n    }\n    create_segment_ring(colors, center, innerRad, outerRad, index) {\n        let count = colors.length;\n        let offset = Math.PI / count;\n        let paths = [];\n        for (let i = 0; i < count; i++) {\n            let deg = Math.PI * 2 / count * i - offset;\n            let deg2 = Math.PI * 2 / count * (i + 1) - offset\n            let p = this.create_segment(center, innerRad, outerRad, deg, deg2);\n            p.fillColor = colors[i]\n            p.onMouseDown = function (e) {\n                colorPickerSvg.selectColor([index, i])\n            }\n            paths.push(p);\n        }\n        return paths;\n    }\n    create_segment(center, innerRad, outerRad, startDeg, endDeg) {\n        function getPointFromDeg(deg, center, rad) {\n            let x = Math.sin(deg) * rad;\n            let y = -Math.cos(deg) * rad;\n            return center.add(new paper.Point(x, y));\n        }\n\n        let p = new paper.Path();\n        let middleDeg = (startDeg + endDeg) / 2;\n        p.moveTo(getPointFromDeg(startDeg, center, outerRad));\n        p.arcTo(getPointFromDeg(middleDeg, center, outerRad), getPointFromDeg(endDeg, center, outerRad));\n        p.lineTo(getPointFromDeg(endDeg, center, innerRad));\n        p.arcTo(getPointFromDeg(middleDeg, center, innerRad), getPointFromDeg(startDeg, center, innerRad));\n        p.closePath();\n        return p;\n    }\n\n    selectColor(index_arr) {\n        this.selectedColor = index_arr\n        let path = this.colorPaths[index_arr[0]][index_arr[1]];\n        if (this.outline !== null) {\n            this.outline.remove();\n            // let seg = path.segments.slice();\n            // this.outline.tween({segments:seg},1000)\n        }\n        this.outline = path.clone();\n        this.outline.fillColor = \"#FFFFFF00\"\n        this.outline.strokeWidth = 4;\n        this.outline.bringToFront();\n        this.outline.strokeColor = 'white';\n    }\n    getColor() {\n        let path = this.colorPaths[this.selectedColor[0]][this.selectedColor[1]];\n        return path.fillColor;\n    }\n}","// import { drawingCanvas } from \"../drawing\";\nimport PaperCanvas from \"../paper-canvas\";\nimport { sendPath } from \"../actions\";\n// import { objectStore, currentRoomId,drawingCanvas } from \"../main\";\n// import { matrixClient } from '../main'//backend;\nimport { GetToolStrokeWidthIndex } from \"./line-style-selector\";\nimport { GetPickerColor } from \"../color-picker\";\nimport { mousePathToString, paperPathToString, pathPosSizeCorrection, setAlpha } from \"../helper\";\nexport default class ToolPen {\n    constructor(marker = false) {\n        this.isMarker = marker\n\n        // Tool state\n        this.mouse_path = [];\n        this.mouse_path_last_time = Date.now();\n        this.last_pos = []\n        this.tool_canceled = false;\n\n        // Tool settings\n        this.strokeWidthOptions = [1, 2, 4, 8];\n\n        this.previewItem = null;\n\n        this.previewPaths = [];\n        this.previewPathTween = null;\n    }\n    getStrokeWidth() {\n        return this.strokeWidthOptions[GetToolStrokeWidthIndex()] * (this.isMarker ? 10 : 1);\n    }\n    getStrokeColor() {\n        return this.isMarker ? setAlpha(GetPickerColor(), 0.1) : GetPickerColor();\n    }\n    tooldown(proX, proY, pressure) {\n        this.tool_canceled = false;\n\n        this.mouse_path_start_time = Date.now();\n        this.last_pos = [0, proX, proY, pressure];\n        this.mouse_path = [[0, proX, proY, pressure * 4]];\n\n        appData.drawingCanvas.activateToolLayer()\n        for (let path of this.previewPaths) {\n            if (!path.visible) {\n                path.remove()\n            }\n        }\n        this.previewPaths.filter((path) => { path.visible })\n\n        let prev = new Path();\n        this.previewPaths.push(prev);\n\n        let colorAlpha = new Color(this.getStrokeColor());\n        colorAlpha.alpha = colorAlpha.alpha * 0.6;\n        // let colorAlpha = setAlpha(this.getStrokeColor(), 0.3);\n        prev.strokeColor = colorAlpha;\n        prev.strokeWidth = this.getStrokeWidth();\n        prev.strokeCap = \"round\"\n        prev.moveTo(new Point(proX, proY))\n        appData.drawingCanvas.activateDrawLayer()\n\n        console.log(\"tooldown\");\n    }\n    toolmove(proX, proY, pressure) {\n        console.log(\"toolmove\");\n        // no pressure for now\n        pressure = 1;\n        let x = proX;\n        let y = proY;\n        let time_delta = Math.min(80, Date.now() - this.mouse_path_last_time);\n        let thickness_factor = 1\n        this.mouse_path_last_time = Date.now();\n\n        let currentPos = [time_delta, x, y, (pressure * 2 + Math.min(3, Math.max(0.0, thickness_factor)))];\n        let dist = (currentPos[1] - this.last_pos[1]) ** 2 + (currentPos[2] - this.last_pos[2]) ** 2\n\n        // let velocity = dist / Math.max(1, time_delta);\n        // let thickness_factor = 1.5 - velocity / 8.0;\n        // todo fix pressure\n        let currentPosPoint = new Point(currentPos[1], currentPos[2])\n        this.mouse_path.push(currentPos);\n        this.previewPaths[this.previewPaths.length - 1].lineTo(currentPosPoint);\n        this.previewPaths[this.previewPaths.length - 1].smooth()\n        // appData.drawingCanvas.drawSegmentDisplay([this.last_pos, currentPos], this.getStrokeColor(), this.getStrokeWidth());\n        this.last_pos = currentPos;\n\n    }\n    toolpreviewmove(pos) {\n        if (this.previewItem === null) {\n            appData.drawingCanvas.activateToolLayer()\n            this.previewItem = new Path.Circle(new Point(0, 0), 0.5);\n            this.previewItem.applyMatrix = false\n            appData.drawingCanvas.activateDrawLayer()\n        }\n        this.previewItem.scaling = new Point(this.getStrokeWidth(), this.getStrokeWidth())\n        this.previewItem.fillColor = this.getStrokeColor();\n        this.previewItem.position = pos;\n    }\n    toolup(proX, proY) {\n        if (this.tool_canceled) { return; }\n        if (appData.objectStore.hasRoom(appData.matrixClient.currentRoomId)) {\n            let [corrected_mouse_path, pos, size] = pathPosSizeCorrection(this.mouse_path);\n            let string_path;\n            let version;\n            // if (appData.drawingCanvas instanceof UnlimitedCanvas) {\n            //     string_path = mousePathToString(corrected_mouse_path);\n            //     version = 1;\n            // }\n            // else \n            if (appData.drawingCanvas instanceof PaperCanvas) {\n                let paper_mouse_path = new Path(corrected_mouse_path.map((s) => { return [s[1], s[2]] }));\n                paper_mouse_path.simplify(1 / appData.drawingCanvas.getZoom());\n                string_path = paperPathToString(paper_mouse_path)[2];\n                paper_mouse_path.remove();\n                version = 2;\n            }\n            sendPath(appData.matrixClient.client, appData.matrixClient.currentRoomId,\n                string_path,\n                this.getStrokeColor(), '#00000000', pos, size, this.getStrokeWidth(), false, version);\n\n        } else {\n            console.log(\"NO ROOM SELECTED TO DRAW IN!\")\n            appData.drawingCanvas.updateDisplay_DEPRECATED();\n        }\n        this.toolcancel();\n    }\n    toolcancel() {\n        console.log(\"CANCEL\");\n        this.mouse_path = [];\n        this.mouse_path_last_time = Date.now();\n        this.last_pos = []\n        this.tool_canceled = true;\n\n        let prev = this.previewPaths[this.previewPaths.length - 1]\n        let l = prev.length;\n        prev.dashArray = [l, l]\n        prev.tween({ dashOffset: 0 }, { dashOffset: -l }, 2 * l).then((e) => {\n            prev.visible = false\n        });\n    }\n    activate() {\n        if (this.previewItem) {\n            this.previewItem.visible = true;\n        }\n    }\n    deactivate() {\n        if (this.previewItem) {\n            this.previewItem.visible = false;\n        }\n    }\n}","import ToolPen from './tools/tool-pen.js'\nimport ToolEraser from './tools/tool-eraser.js'\nimport ToolLine from './tools/tool-line.js'\nimport ToolRect from './tools/tool-rect.js'\n// import { drawingCanvas } from './main.js'\nimport { dist } from './helper.js'\n\nexport var tools = {\n    \"tool-type-pen\": new ToolPen(),\n    \"tool-type-eraser\": new ToolEraser(),\n    \"tool-type-marker\": new ToolPen(true),\n    \"tool-type-line\": new ToolLine(),\n    \"tool-type-square\": new ToolRect(),\n    \"tool-type-ellipse\": null,\n    \"tool-type-text\": null,\n    \"tool-type-line-width\": null\n}\nexport var activeTool = tools[\"tool-type-pen\"];\nfunction over_handler(event) { }\nfunction enter_handler(event) { }\n\nvar touchesCache = [];\nvar touchesCacheBegin = [];\nvar touchZoomCache = 0;\nvar touchPanCache = new DOMPoint(0, 0);\nexport function setActiveTool(id){\n    activeTool = tools[id];\n}\nexport default function init_input(element) {\n    var el = element;\n    // POINTER\n    el.onpointerdown = function (e) {\n        // e.preventDefault();\n        console.log(\"onpointerdown\");\n        let project_pt = appData.drawingCanvas.getTransformedPointer(e.offsetX, e.offsetY);\n        if (e.pointerType == \"touch\") {\n            if (touchesCache.length == 0) {\n                activeTool.tooldown(project_pt.x, project_pt.y, e.pressure);\n            } else {\n                activeTool.toolcancel();\n                touchZoomCache = appData.drawingCanvas.getZoom();\n            }\n            touchesCacheBegin.push(e);\n            touchesCache.push(e);\n        } else {\n            // let project_pt = appData.drawingCanvas.getTransformedPointer(e.offsetX, e.offsetY);\n            activeTool.tooldown(project_pt.x, project_pt.y, e.pressure);\n        }\n    };\n    el.onpointermove = function (e) {\n        // e.preventDefault()\n        // console.log(\"onpointermove\");\n        if ((e.buttons == 1 && (e.pointerType == \"mouse\" || e.pointerType == \"pen\"))\n            || (e.pointerType == 'touch' && touchesCache.length < 2)) {\n            let project_pt = appData.drawingCanvas.getTransformedPointer(e.offsetX, e.offsetY);\n            activeTool.toolmove(project_pt.x, project_pt.y, e.pressure);\n        } else if (e.buttons == 4 && (e.pointerType == \"mouse\" || e.pointerType == \"pen\")) {\n            let offset = new paper.Point(e.movementX, e.movementY)\n            appData.drawingCanvas.offset(offset.divide(appData.drawingCanvas.getZoom()));\n        }\n        else if (touchesCache.length == 2 && e.pointerType == \"touch\") {\n            let index = touchesCache.findIndex((el) => { return e.pointerId === el.pointerId });\n            touchesCache[index] = e;\n            handlePanZoom();\n        }\n        activeTool.toolpreviewmove(appData.drawingCanvas.getTransformedPointer(e.offsetX, e.offsetY))\n    };\n    el.onpointerup = function (e) {\n        console.log(\"onpointerup\");\n        let project_pt = appData.drawingCanvas.getTransformedPointer(e.offsetX, e.offsetY);\n        if (e.pointerType == \"touch\") {\n            touchesCache = touchesCache.filter((cache_event) => { cache_event.pointerId == e.pointerId });\n            touchesCacheBegin = touchesCacheBegin.filter((cache_event) => { cache_event.pointerId == e.pointerId });\n            touchPanCache = new DOMPoint(0, 0);\n            handleTouchType = \"\";\n            touchZoomCache = 0;\n            if (!activeTool.tool_canceled) {\n                activeTool.toolup(project_pt.x, project_pt.y, e.pressure);\n            }\n        } else {\n            activeTool.toolup(project_pt.x, project_pt.y, e.pressure);\n        }\n    };\n\n    // WHEEL\n    el.onwheel = function (e) {\n        e.preventDefault();\n        if (e.ctrlKey) {\n            //ctrl is used as the indicator for pinch gestures... (Not a fan...)\n            zoom(e.offsetX, e.offsetY, 1 + e.wheelDeltaY);\n        } else {\n            let scroll_speed = 0.5;\n            let offset = new paper.Point(e.wheelDeltaX * scroll_speed, e.wheelDeltaY * scroll_speed);\n            appData.drawingCanvas.offset(offset.divide(appData.drawingCanvas.getZoom()));\n        }\n    };\n    // unused\n    el.onpointerover = over_handler;\n    el.onpointerenter = enter_handler;\n    // el.onpointercancel = cancel_handler;\n    // el.onpointerout = out_handler;\n    // el.onpointerleave = leave_handler;\n    // el.gotpointercapture = gotcapture_handler;\n    // el.lostpointercapture = lostcapture_handler;\n    // el.ontouchend = (e) => {\n    //     // e.preventDefault();\n    // };\n    el.addEventListener(\"touchstart\", (e) => {\n        e.preventDefault();\n    }, { passive: false });\n    el.addEventListener(\"gesturestart\", (e) => {\n        e.preventDefault();\n    }, { passive: false });\n    // el.ontouchstart = (e) => {\n    //     e.preventDefault();\n    // };\n    // el.ontouchmove = (e) => {\n    //     // e.preventDefault();\n    // };\n}\n\n\nfunction scroll(deltaX, deltaY) {\n    let scroll_speed = 0.5;\n    appData.drawingCanvas.offset(new paper.Point(deltaX * scroll_speed, deltaY * scroll_speed));\n}\nfunction zoom(offsetX, offsetY, factor) {\n    let zoom_speed = 0.004;\n    appData.drawingCanvas.zoom(1 + factor * zoom_speed, new paper.Point(offsetX, offsetY));\n}\nvar touchZoomCache = 0;\nvar touchPanCache = new DOMPoint(0, 0);\nvar handleTouchType = \"\"\nfunction handlePanZoom() {\n    let drawC=appData.drawingCanvas\n    let cx = drawC.canvas.getBoundingClientRect().x;\n    let cy = drawC.canvas.getBoundingClientRect().y;\n    let canvasZoom = drawC.getZoom();\n    let start1 = drawC.getTransformedPointer(touchesCacheBegin[0].clientX - cx, touchesCacheBegin[0].clientY - cy);\n    let start2 = drawC.getTransformedPointer(touchesCacheBegin[1].clientX - cx, touchesCacheBegin[1].clientY - cy);\n    let current1 = drawC.getTransformedPointer(touchesCache[0].clientX - cx, touchesCache[0].clientY - cy);\n    let current2 = drawC.getTransformedPointer(touchesCache[1].clientX - cx, touchesCache[1].clientY - cy);\n    var PINCH_THRESHOLD = 70 //drawC.canvas.clientWidth / 40;\n    var PAN_THRESHOLD = 40\n    var distStart = dist(start1, start2);\n    var distCurrent = dist(current1, current2);\n    var currentCenter = current1.add(current2).multiply(0.5); //new paper.Point((current1.x + current2.x) / 2, (current1.y + current2.y) / 2)\n    var startCenter = start1.add(start2).multiply(0.5); //[(start1.x + start2.x) / 2, (start1.y + start2.y) / 2]\n    var panDistDelta = dist(currentCenter, startCenter) * canvasZoom;\n    var pinchDistDelta = Math.abs(distStart - distCurrent) * canvasZoom;\n    // console.log(\"pinch Dist: \", panDistDelta)\n    // console.log(\"pan Dist: \", pinchDistDelta)\n    if (pinchDistDelta < PINCH_THRESHOLD && panDistDelta < PAN_THRESHOLD) {\n        return\n    }\n    if (handleTouchType == \"\") {\n        handleTouchType = pinchDistDelta > panDistDelta ? \"pinch\" : \"pan\"\n    }\n    if (handleTouchType == \"pinch\") {\n        // Zoom\n        var currentZoomFactor = distCurrent / distStart;\n        // console.log(\"zoomFactor: \", currentZoomFactor);\n        //TODO some log or exp to make absolute zoom... Maybe not. feels just fine as it is...\n        drawC.setZoom(touchZoomCache * currentZoomFactor, startCenter);\n        // touchZoomCache = distCurrent / distStart;\n    }\n    if (handleTouchType == \"pan\") {\n        // Pan\n        var offset = startCenter.subtract(currentCenter) //new DOMPoint(startCenter[0] - currentCenter[0], startCenter[1] - currentCenter[1]);\n        // console.log(\"offset: \", offset);\n        var offsetDiff = new paper.Point(touchPanCache.x - offset.x, touchPanCache.y - offset.y);\n        touchPanCache = offset;\n        // console.log(\"offsetDiff: \", offsetDiff, drawC.getZoom());\n        // multipy with zoom\n        drawC.offset(offsetDiff);\n    }\n}\n","// import {  } from \"../drawing\";\n// import { objectStore } from '../main'\n// import {  } from '../main'//backend;\nimport { GetToolStrokeWidthIndex } from \"./line-style-selector\";\nimport { mousePathToString, paperPathToString, pathPosSizeCorrection, setAlpha } from \"../helper\";\n\n\nexport default class ToolEraser {\n    constructor() {\n\n        // Tool state\n        this.removedElementsArray\n        this.tool_canceled = false\n        this.idsToDelete = []\n\n        // Tool settings\n        // this.strokeWidth = 10;\n        this.strokeWidthOptions = [5, 10, 20, 40];\n\n        // Preview\n        this.previewItem = null\n\n    }\n\n    getStrokeWidth() {\n        return this.strokeWidthOptions[GetToolStrokeWidthIndex()];\n    }\n    tooldown(proX, proY, pressure) {\n        this.tool_canceled = false;\n        this.addItemsFromPoint(new paper.Point(proX, proY))\n        console.log(\"tooldown\");\n    }\n    toolmove(proX, proY, pressure) {\n        console.log(\"toolmove\");\n        this.addItemsFromPoint(new paper.Point(proX, proY))\n    }\n    addItemsFromPoint(testPoint) {\n        var hitOptions = {\n            stroke: true,\n            tolerance: this.getStrokeWidth(),\n            match: function (hitRes) {\n                return !(\"markedForDeletion\" in hitRes.item.data)\n                    && (\"id\" in hitRes.item.data)\n            }\n        };\n\n        var hitResult = paper.project.hitTest(testPoint, hitOptions);\n        var i = 0;\n        while (hitResult && i < 10) {\n            if (!hitResult) { continue }\n            console.log('hitResult', hitResult);\n            if (appData.objectStore.getById(hitResult.item.data.id).sender == appData.matrixClient.client.getUserId()) {\n                hitResult.item.opacity = 0.5;\n                hitResult.item.data.markedForDeletion = true\n                this.idsToDelete.push(hitResult.item.data.id)\n                hitResult = paper.project.hitTest(testPoint, hitOptions);\n            }\n            i++;\n        }\n    }\n    toolup(proX, proY) {\n        if (this.tool_canceled) { return; }\n\n        // console.log(\"try to erase\");\n        // let pt = drawingCanvas.getTransformedPointer(proX, proY);\n        // let sortedEvents = objectStore.allSorted();\n        // var id = \"\"\n        // let eraser_size = 70;\n        // let userId = matrixClient.getUserId();\n        // for (let i = sortedEvents.length - 1; i >= 0; i--) {\n        //     let event = sortedEvents[i];\n        //     if (event.type == \"p.whiteboard.object\" && event.sender == userId) {\n        //         let points = parsePath(event.content.path, event.content.objpos);\n        //         for (let j in points) {\n        //             let p = points[j];\n        //             if ((pt.x - p[1]) ** 2 + (pt.y - p[2]) ** 2 < eraser_size) {\n        //                 id = event.event_id;\n        //                 break;\n        //             }\n        //         }\n        //     }\n        // }\n        this.toolcancel();\n\n        console.log(this.idsToDelete)\n        for (let id of this.idsToDelete) {\n            console.log(id)\n            appData.matrixClient.client.redactEvent(appData.matrixClient.currentRoomId, id).then(t => {\n                console.log(\"redacted (eraser): \", t);\n            });\n            this.idsToDelete = this.idsToDelete.filter((itemId) => { return itemId == id })\n            // await sleep(300);\n        }\n        this.idsToDelete = [];\n\n    }\n    toolcancel() {\n        console.log(\"CANCEL\");\n        this.tool_canceled = true;\n    }\n    toolpreviewmove(pos) {\n        if (this.previewItem === null) {\n            appData.drawingCanvas.activateToolLayer()\n            this.previewItem = new paper.Path.Circle(new paper.Point(0, 0), 1);\n            this.previewItem.fillColor = '#00000000'\n            this.previewItem.strokeWidth = 1\n            this.previewItem.strokeColor = '#999'\n            this.previewItem.dashArray = [3, 3]\n            this.previewItem.strokeCap = 'round'\n            // this.previewItem.applyMatrix = false\n            // this.previewItem.scaling = new paper.Point(this.getStrokeWidth(), this.getStrokeWidth())\n            appData.drawingCanvas.activateDrawLayer()\n        }\n        if (this.previewItem.bounds.size.width != 2 * this.getStrokeWidth()) {\n            let w = 2 * this.getStrokeWidth() / this.previewItem.bounds.size.width\n            this.previewItem.scaling = new paper.Point(w, w)\n        }\n        this.previewItem.position = pos;\n    }\n    activate() {\n        if (this.previewItem) {\n            this.previewItem.visible = true\n        }\n    }\n    deactivate() {\n        this.previewItem.visible = false\n    }\n}","// import { drawingCanvas } from \"../drawing\";\nimport { sendPath } from \"../actions\";\n// import { objectStore, currentRoomId,drawingCanvas } from '../main'\n// import { matrixClient } from '../main'//backend;\nimport { GetPickerColor } from \"../color-picker\";\n// import { Path, Color, Point } from \"paper/dist/paper-core\";\nimport { GetToolStrokeWidthIndex } from \"./line-style-selector\";\nimport { mousePathToString, paperPathToString, pathPosSizeCorrection, setAlpha } from \"../helper\";\n\n\nexport default class ToolLine {\n    constructor() {\n\n        // Tool state\n        this.canvas_line = null;\n        // this.mouse_path_last_time = Date.now();\n        // this.last_pos = []\n        this.tool_canceled = true;\n\n        // Tool settings\n        // this.strokeWidth = 2;\n        this.strokeWidthOptions = [1, 2, 4, 8];\n    }\n    getStrokeWidth(){\n        return this.strokeWidthOptions[GetToolStrokeWidthIndex()];\n    }\n    tooldown(proX, proY, pressure) {\n        this.tool_canceled = false;\n        let pt = new paper.Point(proX, proY);\n        this.canvas_line = new paper.Path([pt,pt])\n        let colorAlpha = setAlpha(GetPickerColor(), 0.3);\n        this.canvas_line.strokeColor = colorAlpha;\n        this.canvas_line.strokeWidth = this.getStrokeWidth();\n        this.canvas_line.strokeCap = \"round\"\n        // this.mouse_path_start_time = Date.now();\n        // this.last_pos = [0, pt.x, pt.y, pressure];\n        // this.mouse_path = [[0, pt.x, pt.y, pressure * 4]];\n        console.log(\"tooldown\");\n    }\n    toolmove(proX, proY, pressure) {\n        console.log(\"toolmove\");\n        this.canvas_line.lastSegment.point = new paper.Point(proX, proY);\n    }\n\n    toolup(proX, proY) {\n        if (this.tool_canceled) { return; }\n        if (appData.objectStore.hasRoom(appData.matrixClient.currentRoomId)) {\n            // let [corrected_mouse_path, pos, size] = pathPosSizeCorrection([[0,this.canvas_line.firstSegment.point.x,this.canvas_line.firstSegment.point.y,0],[0,this.canvas_line.lastSegment.point.x,this.canvas_line.lastSegment.point.y,0]]);\n\n            // let paper_mouse_path = new paper.Path(corrected_mouse_path.map((s) => { return [s[1], s[2]] }));\n            \n            let [pos, size, string_path] = paperPathToString(this.canvas_line);\n            // paper_mouse_path.remove();\n            let version = 2;\n            sendPath(appData.matrixClient.client, appData.matrixClient.currentRoomId,\n                string_path,\n                GetPickerColor(),'#00000000', [pos.x,pos.y], [size.width,size.height], this.getStrokeWidth(), false, version);\n        } else {\n            console.log(\"NO ROOM SELECTED TO DRAW IN!\")\n            appData.drawingCanvas.updateDisplay_DEPRECATED();\n        }\n        this.toolcancel();\n    }\n    toolcancel() {\n        console.log(\"CANCEL\");\n        if(this.canvas_line !== null){\n            this.canvas_line.remove();\n        }\n        this.canvas_line = null;\n        this.tool_canceled = true;\n    }\n    toolpreviewmove(pos){}\n    activate(){}\n    deactivate(){}\n}","// import { drawingCanvas } from \"../drawing\";\n// import { Path, Color, Point } from \"paper/dist/paper-core\";\nimport { GetPickerColor } from \"../color-picker\";\nimport { GetToolStrokeWidthIndex } from \"./line-style-selector\";\nimport { sendPath } from \"../actions\";\n// import { objectStore, currentRoomId, drawingCanvas} from \"../main\";\n// import { matrixClient } from '../main'//backend;\nimport { mousePathToString, paperPathToString, pathPosSizeCorrection, setAlpha } from \"../helper\";\n\nexport default class ToolRect {\n    constructor() {\n\n        // Tool state\n        this.canvas_rect = null;\n\n        // Tool settings\n        this.strokeWidthOptions = [1, 2, 4,8];\n    }\n    getStrokeWidth(){\n        return this.strokeWidthOptions[GetToolStrokeWidthIndex()];\n    }\n\n    tooldown(proX, proY, pressure) {\n        this.tool_canceled = false;\n        let pt = new paper.Point(proX, proY);\n        appData.drawingCanvas.activateToolLayer();\n        this.canvas_rect = new paper.Path.Rectangle(pt, pt)\n        let colorAlpha = setAlpha(GetPickerColor(), 0.3);\n        this.canvas_rect.strokeColor = colorAlpha;\n        this.canvas_rect.strokeWidth = this.getStrokeWidth();\n        this.canvas_rect.strokeCap = \"round\"\n        // this.mouse_path_start_time = Date.now();\n        // this.last_pos = [0, pt.x, pt.y, pressure];\n        // this.mouse_path = [[0, pt.x, pt.y, pressure * 4]];\n        appData.drawingCanvas.activateDrawLayer();\n        console.log(\"tooldown\");\n    }\n    toolmove(proX, proY, pressure) {\n        console.log(\"toolmove\");\n        this.canvas_rect.segments[1].point.x = proX\n        this.canvas_rect.segments[2].point.x = proX\n        this.canvas_rect.segments[2].point.y = proY\n        this.canvas_rect.segments[3].point.y = proY\n        // this.canvas_rect.lastSegment.point = new paper.Point(proX, proY);\n    }\n\n    toolup(proX, proY) {\n        if (this.tool_canceled) { return; }\n        if (appData.objectStore.hasRoom(appData.matrixClient.currentRoomId)) {\n            // let [corrected_mouse_path, pos, size] = pathPosSizeCorrection([[0,this.canvas_rect.firstSegment.point.x,this.canvas_rect.firstSegment.point.y,0],[0,this.canvas_rect.lastSegment.point.x,this.canvas_rect.lastSegment.point.y,0]]);\n\n            // let paper_mouse_path = new paper.Path(corrected_mouse_path.map((s) => { return [s[1], s[2]] }));\n\n            let [pos, size, string_path] = paperPathToString(this.canvas_rect);\n            // paper_mouse_path.remove();\n            let version = 2;\n            sendPath(appData.matrixClient.client, appData.matrixClient.currentRoomId,\n                string_path,\n                GetPickerColor(), setAlpha(GetPickerColor(), 0.08),[pos.x, pos.y], [size.width, size.height], this.getStrokeWidth(), true, version);\n        } else {\n            console.log(\"NO ROOM SELECTED TO DRAW IN!\")\n            appData.drawingCanvas.updateDisplay_DEPRECATED();\n        }\n        this.toolcancel();\n    }\n    toolcancel() {\n        console.log(\"CANCEL\");\n        if (this.canvas_rect !== null) {\n            this.canvas_rect.remove();\n            this.canvas_rect = null;\n            this.tool_canceled = true;\n        }\n    }\n    toolpreviewmove(pos){}\n    activate(){}\n    deactivate(){}\n}","export default class NotebookTree {\n    constructor() {\n        this.notebooks = {}\n        this.whiteboards = []\n    }\n    clear() {\n        this.notebooks = {}\n        this.whiteboards = []\n    }\n}","import { hideLoading, showLoading } from \"../main\";\nimport { AutoDiscovery } from \"matrix-js-sdk\";\n\nconst loginContainerTemplate = document.createElement('template');\nloginContainerTemplate.innerHTML = `\n<link href=\"style.css\" rel=\"stylesheet\" type=\"text/css\">\n<style>\n    span {\n        font-size: 3em;\n        white-space: pre;\n        font-weight: 100;\n    }\n    input {\n        width: 100%;\n        padding: 12px 20px;\n        margin: 8px 0;\n        display: inline-block;\n        border: 1px solid #ccc;\n        border-radius: 4px;\n        box-sizing: border-box;\n    }\n    button.submit {\n        width: 100%;\n        background-color: #FFAF50;\n        background-color: #4CAF50;\n        color: white;\n        padding: 14px 20px;\n        margin: 8px 0;\n        border: none;\n        border-radius: 4px;\n        cursor: pointer;\n    }\n</style>\n<div class='center-container' id='login-container'>\n    <p>\n        <span>The Board</span>\n        <span style='font-size: 1em;'> (alpha `+process.env.PACKAGE_VERSION+`)</span>\n    </p>\n    <form action=\"javascript:void(0);\" onsubmit=\"()=>{return false;}\">\n    <label for='username'>Username:</label><br>\n    <input type='text' id='username' name='username' autocomplete=\"username\" placeholder='Your matrix id...'><br>\n    <label for='password'>Password:</label><br>\n    <input type='password' id='password' name='password' autocomplete=\"current-password\" placeholder='your password...'><br>\n    <label for='server'>Server:</label><br>\n    <input type='text' id='server-url' name='server' placeholder='Server url'><br>\n    <button id='login-submit' class='submit'>Log in</button>\n    </form>\n</div>\n`\nexport class LoginContainer extends HTMLElement {\n    constructor() {\n        super();\n    }\n    checkUsername(username) {\n        let re = new RegExp(\"@[a-zA-Z0-9_.+-]+\\\\:[a-zA-Z0-9-]+\\\\.[a-zA-Z0-9-.]+$\")\n        if (re.test(username)) {\n            let serverDomain = username.split(\":\")[1];\n            showLoading(\"Getting homeserver Information for domain \" + serverDomain);\n            AutoDiscovery.findClientConfig(serverDomain)\n                .then((clientConf) => {\n                    hideLoading();\n                    let baseUrl = clientConf[\"m.homeserver\"].base_url;\n                    if (baseUrl) {\n                        this.shadowRoot.querySelector(\"#server-url\").value = baseUrl;\n                    }\n                })\n            return true\n        }\n        return false\n    }\n    hide() {\n        let login = this.shadowRoot.querySelector(\"#login-container\");\n        login.style.display = \"none\"\n    }\n    loginClicked() {\n\n        function checkpwd(pwd) {\n            console.log(\"pwd to check: \", pwd);\n\n            return pwd.length > 1;\n        }\n        function checkServerUrl(baseUrl) {\n            return baseUrl.length > 5\n        }\n        let baseUrl = this.shadowRoot.querySelector(\"#server-url\").value;\n        let username = this.shadowRoot.querySelector(\"#username\").value;\n        let pwd = this.shadowRoot.querySelector(\"#password\").value;\n\n        console.log(\"username to check: \", username);\n        if (checkpwd(pwd) && this.checkUsername(username) && checkServerUrl(baseUrl)) {\n            appData.matrixClient.login(username, pwd, baseUrl, ()=>{this.hide()});\n        } else {\n            showLoading(\"username or password dont have the correct format\")\n        }\n    }\n\n    connectedCallback() {\n        this.attachShadow({ mode: 'open' });\n        let content = loginContainerTemplate.content;\n        content.getElementById(\"login-submit\").onclick = (ev) => { this.loginClicked() }\n        content.getElementById(\"username\").onchange = (el) => { this.checkUsername(el.target.value) }\n        var pwd_input = content.getElementById(\"password\");\n        pwd_input.addEventListener(\"keypress\", function (event) {\n            if (event.key === \"Enter\") {\n                event.preventDefault();\n                document.getElementById(\"login-submit\").click();\n            }\n        });\n        this.shadowRoot.appendChild(content);\n    }\n}\nif (!customElements.get('login-container')) {\n    customElements.define('login-container', LoginContainer);\n}\n\n","\nimport init_input from './input.js'\nimport ObjectStore from './sturctures/object-store'\nimport MatrixBackend from './backend/matrix.js';\nimport PaperCanvas from './paper-canvas'\nimport { init_color_picker } from \"./color-picker\";\nimport init_tool_wheel from \"./tools/tool-wheel\";\nimport init_line_style_selector from \"./tools/line-style-selector\";\n// import {matrixClient, scrollback, updateRoomTree, createWhiteboard, makeWhitebaordFromRoom } from './main'//backend\n// import { loginClicked } from \"./actions.js\";\nimport \"./components/login-container\";\n// import './resources/style.css'\n\nwindow.appData = {\n    matrixClient: new MatrixBackend(),\n    objectStore: new ObjectStore(),\n    drawingCanvas: new PaperCanvas()\n}\n// window.appData.drawingCanvas = drawingCanvas;\n\n\n// export var currentRoomId = \"\";\n// export var objectStore = \n// var paper_canvas = new PaperCanvas();\nwindow.onload = function () {\n    appData.drawingCanvas.init();\n    init_input(document.getElementById(appData.drawingCanvas.css_id));\n    init_color_picker();\n    init_tool_wheel();\n    init_line_style_selector();\n\n    // window.actions.scrollback = updateRoomList;\n    window.actions.updateAddRoomList = updateAddRoomList;\n}\nexport function updateRoomList() {\n    let roomTree = appData.matrixClient.updateRoomTree()\n    let leftbarBody = document.getElementById(\"leftbar-body\")\n    leftbarBody.innerHTML = ''\n    for (let noteb of Object.keys(roomTree.notebooks)) {\n        let notebookRoom = appData.matrixClient.client.getRoom(noteb)\n        leftbarBody.appendChild(createNotebook(notebookRoom.name, roomTree.notebooks[noteb]))\n    }\n    for (let whiteboard of roomTree.whiteboards) {\n        leftbarBody.appendChild(createDOMWhiteboard(whiteboard, '#eee'))\n    }\n    // let id = room.roomId;\n    // var roomButton = document.createElement(\"div\");\n    // console.log(id)\n    // roomButton.onclick = function (a) { console.log(a); loadRoom(id); };\n    // roomButton.classList.add(\"room-button\");\n    // var roomText = document.createElement(\"p\");\n    // roomText.innerText = visibleRooms[r].name;\n    // roomButton.appendChild(roomText);\n    // leftbarBody.insertBefore(roomButton, leftbarBody.firstChild);\n}\nfunction createNotebook(name, whiteboards) {\n    let notebook = document.createElement(\"div\")\n    let header = document.createElement(\"div\")\n    let list = document.createElement(\"div\")\n\n    header.innerHTML = name;\n    header.classList.add(\"notebook-header\");\n    let color = Color.random().toCSS()\n    header.style.borderLeftColor = color;\n\n    function getExpandHeight(list) {\n        let height = 0\n        for (let l of list.children) {\n            height += l.getBoundingClientRect().height;\n        }\n        return height;\n    }\n    header.onclick = function (a) {\n        if (list.style.height == \"\") { list.style.height = getExpandHeight(list) }\n        if (list.getBoundingClientRect().height != 0) { list.style.height = 0 }\n        else { list.style.height = getExpandHeight(list) }\n    };\n    notebook.appendChild(header);\n\n    for (let id of whiteboards) {\n        list.appendChild(createDOMWhiteboard(id, color))\n    }\n    list.classList.add(\"notebook-list\");\n    // list.style.height = getExpandHeight(list);\n    notebook.appendChild(list);\n\n    return notebook;\n}\nfunction createDOMWhiteboard(id, color) {\n    let whiteboardButton = document.createElement(\"button\")\n    let room = appData.matrixClient.client.getRoom(id);\n    whiteboardButton.onclick = function (a) { console.log(a); loadRoom(id); };\n    whiteboardButton.classList.add(\"room-button\");\n    whiteboardButton.style.borderLeftColor = color;\n    whiteboardButton.innerHTML = room.name + \"<br><span style='font-size:0.5em;color:#000'>\" + room.roomId + \"</span>\";\n    return whiteboardButton;\n}\nexport async function updateAddRoomList() {\n    let visibleRooms = appData.matrixClient.getVisibleRooms();\n    let addRoomBody = document.getElementById(\"add-room-list\");\n    addRoomBody.innerHTML = \"\"\n    for (let r of visibleRooms) {\n        // let room = visibleRooms[r];\n        console.log(Array.from(r.currentState.events.keys()))\n        if (r.currentState.events.has('m.space.child')\n            || r.currentState.events.has('p.whiteboard.settings')) {\n            continue // only show rooms which are no spaces and are not already a whiteboard\n        }\n        let id = r.roomId;\n        var roomButton = document.createElement(\"div\");\n        roomButton.onclick = async function (a) {\n            console.log(a);\n            a.currentTarget.style.backgroundColor = '#5e5'\n            let room = await makeWhiteboardFromRoom(id);\n            updateAddRoomList();\n            updateRoomList();\n            hideAddRoomMenu();\n        };\n        roomButton.classList.add(\"room-button\");\n        var roomText = document.createElement(\"p\");\n        roomText.innerText = r.name;\n        roomButton.appendChild(roomText);\n        addRoomBody.insertBefore(roomButton, addRoomBody.firstChild);\n    }\n}\nexport function showLoading(msg) {\n    let loading = document.getElementById(\"loading\");\n    loading.style.display = \"block\";\n    let span = document.getElementById(\"loading-span\");\n    span.innerHTML = msg\n}\nexport function hideLoading() {\n    let loading = document.getElementById(\"loading\");\n    loading.style.display = \"none\";\n}\n\n// function cancelRoomLoading() {\n//     return new Promise((resolve, reject) => {\n//         resolve();\n//     });\n// }\nasync function loadRoom(roomId, scrollback_count = -1, allMessages = true) {\n    let drawC = appData.drawingCanvas;\n    console.log(drawC);\n    drawC.clear();\n    drawC.resetOffset();\n    drawC.resetZoom();\n    drawC.setZoom(0.5)\n    showLoading(\"switching Room to: \" + appData.matrixClient.currentRoomId);\n    console.log(\"switching Room to: \" + appData.matrixClient.currentRoomId);\n    document.getElementById('leftbar').classList.remove('no-room-selected');\n    appData.objectStore.addRoom(roomId);\n    appData.matrixClient.currentRoomId = roomId;\n    let s_back = scrollback_count;\n    if (scrollback_count == -1) {\n        if (Object.keys(appData.objectStore.all()).length == 0) { s_back = 300; }\n        else { s_back = 0; }\n    }\n    let room = appData.matrixClient.client.getRoom(roomId);\n    let settings = room.currentState.events.get('p.whiteboard.settings');\n    if (settings.has(\"colorpalette\")) {\n        SetColorPalette(settings.get(\"colorpalette\"))\n    }\n    showLoading(\"load room history\");\n    const dateOptions = { year: 'numeric', month: 'numeric', day: 'numeric', hour: 'numeric' };\n    let scrollBackToken = true\n    let currentScrollbackDate = new Date()\n    let nowDate = new Date();\n    let createDate = new Date(room.currentState.getStateEvents('m.room.create', \"\").event.origin_server_ts);\n    let totalLoaded = 0\n    while (scrollBackToken) {\n        let percent = 1 - ((currentScrollbackDate - createDate) / (nowDate - createDate))\n        let roomLoaded = await appData.matrixClient.scrollback(appData.matrixClient.currentRoomId, s_back, \"Loaded: \" + Math.floor(percent * 100) + \"% (elements: \" + totalLoaded + \")</br> <span style='font-size:10px'>to Date: \" + currentScrollbackDate.toLocaleDateString('de-DE', dateOptions) + \"  Target: \" + createDate.toLocaleDateString('de-DE', dateOptions) + \"</span>\");\n        drawC.updateDisplay_DEPRECATED();\n        currentScrollbackDate = new Date(roomLoaded.timeline[0].event.origin_server_ts);\n        totalLoaded += s_back;\n        scrollBackToken = room.oldState.paginationToken;\n        if (!allMessages) { break; }\n    }\n    drawC.reload();\n    drawC.updateDisplay_DEPRECATED();\n}\n\n\n","import * as sdk from \"matrix-js-sdk\";\nimport { showLoading, hideLoading, updateRoomList } from \"../main\";\nimport NotebookTree from '../sturctures/notebook-tree'\nimport { drawEvent } from '../drawing'\n\nexport default class MatrixBackend {\n    constructor() {\n        this.client = null\n        this.currentRoomId = null\n    }\n\n    updateRoomTree() {\n        let roomTree = new NotebookTree();\n        let dateNow = Date.now()\n        console.log(\"startGettingVisibleRooms\")\n        // return new Promise( (resolve, reject) {\n        let visibleRooms = this.client.getRooms();\n        console.log(\"got all visible rooms\" + (Date.now() - dateNow))\n        let spaces = visibleRooms.filter(r => r.currentState.events.has('m.space.child'))\n\n\n        for (let r in visibleRooms) {\n            let room = visibleRooms[r];\n            console.log(Array.from(room.currentState.events.keys()))\n            if (!room.currentState.events.has('p.whiteboard.settings')) {\n                continue // only show rooms which are marked as whitebaord rooms\n            }\n            let found = spaces.find(spaceRoom => spaceRoom.currentState.events.get('m.space.child').has(room.roomId))\n            if (found) {\n                if (found.roomId in roomTree.notebooks) {\n                    roomTree.notebooks[found.roomId].push(room.roomId)\n                } else {\n                    roomTree.notebooks[found.roomId] = [room.roomId]\n                }\n                console.log(\"whiteboard is in space!: \", found)\n            } else {\n                roomTree.whiteboards.push(room.roomId)\n            }\n        }\n        return roomTree;\n    }\n\n    async createWhiteboard(visibility = \"private\", whiteboardName = \"unnamed Whiteboard\") {\n\n        let roomOpt = {\n            // room_alias_name\n            visibility: visibility,\n            invite: [],\n            name: whiteboardName == \"\" ? \"unnamed Whiteboard\" : whiteboardName,\n        }\n        showLoading(\"Creating whiteboard with Name: \" + whiteboardName)\n        let roomCreateData = await this.client.createRoom(roomOpt);\n        hideLoading();\n        return makeWhitebaordFromRoom(roomCreateData.room_id);\n    }\n\n\n\n\n    async makeWhitebaordFromRoom(roomId) {\n        let content = {}\n        let stateId = await this.client.sendStateEvent(roomId, \"p.whiteboard.settings\", content, \"\")\n        showLoading(\"make Room \" + this.client.getRoom(roomId).name + \"a whiteboard\")\n        let prom = new Promise(function (resolve, reject) {\n            let listenerFunc = function (msg, state, prevEvent) {\n                if (msg.event.event_id == stateId.event_id) {\n                    this.client.removeListener(\"RoomState.events\", listenerFunc)\n                    resolve()\n                    hideLoading()\n                }\n            }\n            this.client.on(\"RoomState.events\", listenerFunc);\n        })\n        return prom;\n    }\n\n\n    async login(username, password, baseUrl, loginCallback) {\n        showLoading(\"login with: \" + username + \" on server: \" + baseUrl);\n        this.client = sdk.createClient({\n            baseUrl: baseUrl\n        });\n        appData.matrixClient = this;\n        window.actions.createWhiteboard = this.createWhiteboard;\n        window.actions.scrollback = this.scrollback;\n        this.setupClientConnections();\n        let registeredResult = await this.client.loginWithPassword(username, password, function (err) {\n            if (err instanceof Error) {\n                showLoading(err.message)\n                return;\n            } else {\n                loginCallback();\n            }\n        })\n        console.log(registeredResult);\n        document.getElementById(\"userIdLabel\").innerHTML = registeredResult.user_id;\n        // document.getElementById(\"userIdLabel\").innerHTML = registeredResult.user_id;\n        showLoading(\"start client\");\n        let startedResult = await this.client.startClient({ initialSyncLimit: 0, lazyLoadMembers: true });\n        showLoading(\"initial sync\");\n    }\n\n\n\n    setupClientConnections() {\n        this.client.on(\"sync\", function (state, prevState, data) {\n            switch (state) {\n                case \"ERROR\":\n                    // update UI to say \"Connection Lost\"\n                    break;\n                case \"SYNCING\":\n                    // update UI to remove any \"Connection Lost\" message\n                    break;\n                case \"PREPARED\":\n                    // the client instance is ready to be queried.\n                    updateRoomList()\n                    showLoading(\"Select a whiteboard or create a new one\")\n                    break;\n            }\n        });\n        this.client.on(\"Room.localEchoUpdated\", function (msg, room, oldId, newStatus) {\n            if (msg.getType() === \"p.whiteboard.object\" && msg.status === \"sent\") {\n                let item = project.getItem({ class: \"Path\", match: function (item) { return item.data.id == oldId } })\n                if (item) {\n                    item.data.id = msg.event.event_id\n                }\n                appData.objectStore.add(msg.event);\n\n                // console.log(\"now its sent\")\n            }\n        })\n        // var replacedEvents = new Set();\n        this.client.on(\"Room.timeline\", function (msg, room, toStartOfTimeline) {\n            if (msg.isRedacted()) {\n                console.log(\"skipped redacted evpped redacted event\")\n                return;\n            }\n            // // message is replaced\n            // if (replacedEvents.has(msg.event.event_id)){\n            //     console.log(\"skipped replaced event\")\n            //     return;\n            // }\n            if (msg.getType() == \"p.whiteboard.object\") {\n                // console.log(\"event from : \", new Date(), msg.getDate());\n                // let content = msg.event.content\n                // if(\"m.relates_to\" in msg.event.content){\n                //     if(msg.event.content[\"m.relates_to\"].rel_type == \"m.replace\"){\n                //         replacedEvents.add(msg.event.content[\"m.relates_to\"].event_id)\n                //         msg.event.content = msg.event.content[\"m.new_content\"];\n                //     }\n                // }\n\n                // if (Date.now() - msg.getDate().getTime() < 200000) {\n                //     // ANIMATED toggle\n                //     drawEvent(msg.event, true);\n                // }\n                // if (Date.now() - msg.getDate().getTime() < 200000) {\n                // ANIMATED toggle\n                drawEvent(msg.event, Date.now() - msg.getDate().getTime() < 200000);\n                // }\n                if (msg.status == null) {\n                    //event is not sending but loaded from scrollback\n                    appData.objectStore.add(msg.event);\n                }\n            }\n            if (msg.getType() == \"m.room.redaction\") {\n                // this is debateable. When an event is super slow the canvas will still show it until some other event happens to trigger a redraw\n                // if (Date.now() - msg.event.origin_server_ts < 200000) {\n                appData.objectStore.redactById(msg.event.redacts, msg.event.room_id);\n                // }\n            }\n            if (msg.getType() !== \"m.room.message\") {\n                return; // only use messages\n            }\n            // console.log(\"event: \",msg)\n            // console.log(msg.event.content.body);\n        });\n    }\n\n\n    scrollback(roomId, scrollback_count = 200, loadingMsg = null) {\n        console.log(\"load scrollback for: \" + roomId);\n        console.log(\"load scrollback with element count: \" + scrollback_count);\n        if (loadingMsg) { showLoading(loadingMsg); } else {\n            showLoading(\"load \" + scrollback_count + \" elements from message history\");\n        }\n        let client = this.client;\n        let curRoomId = this.currentRoomId;\n        return new Promise(function (resolve, reject) {\n            if (scrollback_count == 0) {\n                hideLoading();\n                resolve(client.getRoom(curRoomId));\n            }\n            client.scrollback(client.getRoom(roomId), scrollback_count)\n                .then((room) => {\n                    console.log(\"scrollback loaded\");\n                    hideLoading();\n                    resolve(room);\n                });\n        });\n    }\n}","// import { currentRoomId } from \"../main\";\nexport default class ObjectStore {\n    constructor() {\n        // this.redacted = new Set();\n        this.data = {\n            \"exampleroom\": {\n                \"redacted\": new Set(),\n                \"all\": [],\n                \"allDict\": {},\n                \"user\": [],\n                \"chunk\": [],\n            }\n        }\n    }\n    currentRoom() {\n        return this.data[appData.matrixClient.currentRoomId]\n    }\n    hasRoom(roomId) {\n        return roomId in this.data;\n    }\n    addRoom(roomId) {\n        if (this.hasRoom(roomId)) {\n            console.log(\"room already exists\")\n        }\n        else {\n            console.log(\"add room \" + roomId + \"to store\");\n            this.data[roomId] = {\n                \"redacted\": new Set(),\n                \"all\": [],\n                \"allDict\": {},\n                \"user\": {},\n                \"chunk\": [],\n            }\n        }\n    }\n    // addToCurrent(obj) {\n    //     if (!this.currentRoom().redacted.has(obj.event_id)) {\n    //         this.currentRoom().all.push(obj);\n    //     }\n    // }\n    add(obj) {\n        if (!obj.room_id in this.data) {\n            this.addRoom(obj.room_id);\n        }\n        let room = this.data[obj.room_id];\n        // console.log(\"adding obj that already exists: \", room.all.some(el => el.event_id == obj.event_id));\n        room.allDict[obj.event_id] = obj;\n        // if (!room.redacted.has(obj.event_id)) {\n        // room.all.push(obj);\n        // }\n    }\n    allSorted() {\n        if (appData.matrixClient.currentRoomId in this.data) {\n            let begin_sort = Date.now();\n            let dic = this.currentRoom().allDict;\n            let allList = Object.keys(dic).map(key => dic[key]);\n            allList.sort(function (first, second) {\n                return first.origin_server_ts - second.origin_server_ts;\n            });\n            console.log(\"sorted all events: \", Date.now() - begin_sort, \"ms\")\n            return allList;\n            return this.currentRoom().all;\n        } else {\n            // If there is not current room set, the default behaviour is en empty list -> canvas gets cleared\n            return []\n        }\n    }\n    all() {\n        if (appData.matrixClient.currentRoomId in this.data) {\n            return this.currentRoom().allDict;\n        } else {\n            // If there is not current room set, the default behaviour is en empty list -> canvas gets cleared\n            return {}\n        }\n    }\n    getById(id) {\n        let found = Object.values(this.all()).find(el => el.event_id == id);\n        return found;\n    }\n    // redactByIdInCurrent(id, remove = true) {\n    //     this.currentRoom().redacted.add(id);\n    //     if (remove) {\n    //         this.currentRoom().all = this.currentRoom().all.filter(e => e.event_id !== id);\n    //     }\n    // }\n    redactById(id, roomId, remove = true) {\n        if (!this.hasRoom(roomId)) { this.addRoom(roomId) }\n        let room = this.data[roomId];\n        // room.redacted.add(id);\n        if (remove) {\n            if (id in room.allDict) {\n                delete room.allDict[id];\n                let item = paper.project.getItem({ class: \"Path\", match: function (item) { return item.data.id == id } })\n                if (item) { item.remove(); } else { console.log(\"could not find item for id: \", id) }\n            } else {\n                console.log(\"unecassary redact called for id: \", id)\n            }\n        }\n    }\n    // redact_and_remove_by_id(id){\n    //     this.redacted.add(id);\n    //     this.objects[\"all\"] = this.objects[\"all\"].filter(e => e.event_id !== id);\n    // }\n    // all_region(x,y,width,height){\n    //     //TODO\n    //     var ret = [];\n    //     this.objects[\"all\"].forEach(obj => {\n    //         pos = [obj.objpos.slice(\" \").map(x => {return parseInt(x)})];\n    //         size = [obj.objsize.slice(\" \").map(x => {return parseInt(x)})];\n    //         if obj.\n    //         ret.push()\n    //     });\n    // }\n}","import { Point } from 'paper'\nimport { tools, activeTool } from '../input';\nimport { setActiveTool } from '../input';\nimport { mousePathToString, paperPathToString, pathPosSizeCorrection, setAlpha } from \"../helper\";\n\nexport default function init_tool_wheel() {\n  let wheelContainer = document.getElementById(\"tool-wheel\");\n  let colorPickerCanvas = document.getElementById('color-picker-canvas');\n  let boundingrect = colorPickerCanvas.getBoundingClientRect()\n  let center = new Point(boundingrect.width, boundingrect.height)\n  // center = new Point(208, 208);\n  center = center.multiply(0.5);\n  let children = document.querySelectorAll(\".tool-elements\");\n  // let buttons = document.querySelectorAll(\"#tool-wheel button\");\n  let settingsButton = document.getElementById(\"settings-button\");\n  settingsButton.style.left = center.x\n  settingsButton.style.bottom = center.y\n  let rad = center.x + 15;\n  let offset = -Math.PI / 10;// -Math.PI / 4;\n  for (let i = 0; i < children.length; i++) {\n    // all units in em\n    console.log(children[i].tagName);\n    let child = children[i];\n    let angle = i * Math.PI / 7 + offset;\n    let pos = new Point(Math.sin(angle) * rad, Math.cos(angle) * rad);\n    child.style.left = center.x + pos.x;\n    child.style.bottom = center.y + pos.y;\n  }\n  for (let b of children) {\n    if (!(b.id in tools)) { continue }\n    b.onclick = function (buttonEv) {\n      for (let btn of children) {\n        btn.classList.remove('active');\n      }\n      activeTool.deactivate()\n      setActiveTool(b.id);\n      activeTool.activate()\n      b.classList.add('active');\n\n    }\n    if (activeTool == tools[b.id]) {\n      b.classList.add('active');\n    }\n  }\n}"],"names":["paperPathToString","path","movedPath","clone","boundingRect","bounds","position","subtract","topLeft","paper_path_string","s","segments","point","x","toFixed","y","handleIn","handleOut","remove","size","trim","dist","p","q","Math","sqrt","parsePoint","string","arr","split","paper","Point","parseFloat","setAlpha","color","opacity","_opStr","round","min","max","toString","toUpperCase","length","drawEvent","event","animated","updateDisplay_DEPRECATED","drawC","appData","drawingCanvas","content","objtype","version","p_path","objpos","filter","e","offset","returnval","i","seg","Segment","push","parseBezierPath","strokeWidth","closed","objcolor","fillColor","objFillColor","asyncAddPathV2","event_id","addPathV2","points","time","lineWidth","parsePath","pos","objsize","asyncAddPathV1","drawBoundingBox","addPathV1","PaperCanvas","constructor","this","css_id","displayPaths","toolLayer","drawLayer","canvas","activateToolLayer","activate","activateDrawLayer","init","document","getElementById","setup","install","window","project","activeLayer","Layer","offset_delta","view","center","resetOffset","setOffset","getZoom","zoom","factor","zoomOrigin","scale","zoomOriProj","viewToProject","setZoom","currentViewCenter","resetZoom","console","log","id","dashArray","tween","dashOffset","then","Path","strokeColor","strokeCap","data","moveTo","lineTo","dispPath","clearDisplayPaths","forEach","clear","l","layers","removeChildren","box","reload","starttime","Date","now","objectStore","allSorted","obj","type","getTransformedPointer","sendPath","client","room","string_path","floor","random","sendEvent","err","res","lastEvent","userId","matrixClient","getUserId","sortedEvents","sender","replaceEvent","idToReplace","newContent","currentRoomId","redactEvent","t","actions","redactLastAction","roomId","formSubmit","preventDefault","replaceLastEvent","moveLastEvent","ev","newPoint","add","showAddRoomMenu","updateAddRoomList","style","display","hideAddRoomMenu","showSettingsMenu","settingsMenu","getRoom","innerHTML","hideSettingsMenu","_tool_stroke_width_index","GetToolStrokeWidthIndex","colorPickerSvg","GetPickerColor","getColor","toCSS","ColorPicker","colors","darkColors","map","c","multiply","outline","colorPaths","selectedColor","COLOR_PICKER_BORDER","innerCircle","middleCircle","redraw","cent","divide","radi","width","circleBg","shadowBlur","shadowColor","create_segment_ring","circleInner","setColorPalette","palette","concat","innerRad","outerRad","index","count","PI","paths","deg","deg2","create_segment","onMouseDown","selectColor","startDeg","endDeg","getPointFromDeg","rad","sin","cos","middleDeg","arcTo","closePath","index_arr","bringToFront","ToolPen","marker","isMarker","mouse_path","mouse_path_last_time","last_pos","tool_canceled","strokeWidthOptions","previewItem","previewPaths","previewPathTween","getStrokeWidth","getStrokeColor","tooldown","proX","proY","pressure","mouse_path_start_time","visible","prev","colorAlpha","Color","alpha","toolmove","time_delta","currentPos","currentPosPoint","smooth","toolpreviewmove","Circle","applyMatrix","scaling","toolup","hasRoom","corrected_mouse_path","posMin","Number","MAX_VALUE","posMax","correctedPoints","height","pathPosSizeCorrection","paper_mouse_path","simplify","toolcancel","deactivate","tools","removedElementsArray","idsToDelete","addItemsFromPoint","testPoint","hitOptions","stroke","tolerance","match","hitRes","item","hitResult","hitTest","getById","markedForDeletion","itemId","w","canvas_line","pt","lastSegment","canvas_rect","Rectangle","activeTool","over_handler","enter_handler","touchesCache","touchesCacheBegin","touchZoomCache","touchPanCache","DOMPoint","handleTouchType","NotebookTree","notebooks","whiteboards","loginContainerTemplate","createElement","LoginContainer","HTMLElement","super","checkUsername","username","RegExp","test","serverDomain","showLoading","AutoDiscovery","clientConf","hideLoading","baseUrl","base_url","shadowRoot","querySelector","value","hide","loginClicked","pwd","checkpwd","checkServerUrl","login","connectedCallback","attachShadow","mode","onclick","onchange","el","target","addEventListener","key","click","appendChild","updateRoomList","roomTree","updateRoomTree","leftbarBody","noteb","Object","keys","notebookRoom","createNotebook","name","whiteboard","createDOMWhiteboard","notebook","header","list","classList","getExpandHeight","children","getBoundingClientRect","borderLeftColor","a","whiteboardButton","async","scrollback_count","allMessages","addRoom","s_back","all","settings","currentState","events","get","has","SetColorPalette","dateOptions","year","month","day","hour","scrollBackToken","currentScrollbackDate","nowDate","createDate","getStateEvents","origin_server_ts","totalLoaded","percent","roomLoaded","scrollback","toLocaleDateString","timeline","oldState","paginationToken","loadRoom","visibleRooms","getVisibleRooms","addRoomBody","r","Array","from","roomButton","currentTarget","backgroundColor","makeWhiteboardFromRoom","roomText","innerText","insertBefore","firstChild","msg","customElements","define","dateNow","getRooms","spaces","found","find","spaceRoom","visibility","whiteboardName","roomOpt","invite","roomCreateData","createRoom","makeWhitebaordFromRoom","room_id","stateId","sendStateEvent","Promise","resolve","reject","listenerFunc","state","prevEvent","removeListener","on","password","loginCallback","createWhiteboard","setupClientConnections","registeredResult","loginWithPassword","Error","message","user_id","startClient","initialSyncLimit","lazyLoadMembers","prevState","oldId","newStatus","getType","status","getItem","class","toStartOfTimeline","isRedacted","getDate","getTime","redactById","redacts","loadingMsg","curRoomId","Set","currentRoom","allDict","begin_sort","dic","allList","sort","first","second","values","onload","element","onpointerdown","project_pt","offsetX","offsetY","pointerType","onpointermove","buttons","findIndex","pointerId","cx","cy","canvasZoom","start1","clientX","clientY","start2","current1","current2","distStart","distCurrent","currentCenter","startCenter","panDistDelta","pinchDistDelta","abs","currentZoomFactor","offsetDiff","handlePanZoom","movementX","movementY","onpointerup","cache_event","onwheel","ctrlKey","wheelDeltaY","scroll_speed","wheelDeltaX","onpointerover","onpointerenter","passive","boundingrect","querySelectorAll","settingsButton","left","bottom","tagName","child","angle","b","buttonEv","btn","init_tool_wheel","updateVisiblePreviewItem","previewItems","btnEv","init_line_style_selector"],"sourceRoot":""}