{"version":3,"file":"main.bundle.js","mappings":"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","sources":["webpack://theboard_matrix/./src/backend/board-event-consts.js","webpack://theboard_matrix/./src/backend/filter.js","webpack://theboard_matrix/./src/helper.js","webpack://theboard_matrix/./src/paper-canvas.js","webpack://theboard_matrix/./src/tools/line-style-selector.js","webpack://theboard_matrix/./src/color-picker.js","webpack://theboard_matrix/./src/tools/tool-pen.js","webpack://theboard_matrix/./src/input.js","webpack://theboard_matrix/./src/tools/tool-eraser.js","webpack://theboard_matrix/./src/tools/tool-line.js","webpack://theboard_matrix/./src/tools/tool-rect.js","webpack://theboard_matrix/./src/sturctures/notebook-tree.js","webpack://theboard_matrix/./src/components/login-container.js","webpack://theboard_matrix/./src/actions.js","webpack://theboard_matrix/./src/main.js","webpack://theboard_matrix/./src/backend/matrix.js","webpack://theboard_matrix/./src/sturctures/object-store.js","webpack://theboard_matrix/./src/tools/tool-wheel.js"],"sourcesContent":["export var BOARD_OBJECT_EVENT_NAME = \"com.github.TheBoard.object\"\nexport var BOARD_COMMIT_EVENT_NAME = \"com.github.TheBoard.commit\"\nexport var BOARD_ROOM_STATE_NAME = \"com.github.TheBoard\"","import * as BordEvents from './board-event-consts'\nexport function isBoardObjectEvent(type){\n    return type === \"p.whiteboard.object\" || type === BordEvents.BOARD_OBJECT_EVENT_NAME\n}\nexport function isBoardCommitEvent(type){\n    return type === BordEvents.BOARD_COMMIT_EVENT_NAME\n}\n\nexport function isBoardRoom(events){\n    return events.has(BordEvents.BOARD_ROOM_STATE_NAME) || events.has('p.whiteboard.settings')\n}","export function parsePath(p_path, objpos) {\n    let arr = p_path.split(\" \");\n    var offset = objpos.split(\" \");\n    var returnval = [];\n    for (let i = 0; i < arr.length; i += 4) {\n        let time = parseFloat(arr[i]);\n        let x = parseFloat(arr[i + 1]) + parseFloat(offset[0]);\n        let y = parseFloat(arr[i + 2]) + parseFloat(offset[1]);\n        let lineWidth = parseFloat(arr[i + 3]);\n        returnval.push([time, x, y, lineWidth]);\n    }\n    return returnval;\n}\nexport function parseBezierPath(p_path, objpos) {\n    let arr = p_path.split(\" \");\n    arr = arr.filter((e)=>e!=\"\")\n    var offset = objpos.split(\" \");\n    var returnval = [];\n    for (let i = 0; i < arr.length; i += 6) {\n        let seg = new paper.Segment(\n            new paper.Point(parseFloat(arr[i + 0]) + parseFloat(offset[0]),\n                parseFloat(arr[i + 1]) + parseFloat(offset[1])),\n            new paper.Point(parseFloat(arr[i + 2]), parseFloat(arr[i + 3])),\n            new paper.Point(parseFloat(arr[i + 4]), parseFloat(arr[i + 5])))\n        // let time = parseFloat(arr[i]);\n        // let x = parseFloat(arr[i + 1]) + parseFloat(offset[0]);\n        // let y = parseFloat(arr[i + 2]) + parseFloat(offset[1]);\n        // let lineWidth = parseFloat(arr[i + 3]);\n        returnval.push(seg);\n    }\n    return returnval;\n}\nexport function mousePathToString(points) {\n    //format:\n    // time x y width\n    let mouse_path_string = \"\";\n    for (let p of points) {\n        mouse_path_string += p[0] + \" \" + p[1] + \" \" + p[2] + \" \" + p[3] + \" \";\n    }\n    return mouse_path_string;\n}\nexport function paperPathToString(path) {\n    //format:\n    // x y handleInX handleInY handleOutX handleOutY\n    let movedPath = path.clone();\n    let boundingRect = movedPath.bounds;\n    movedPath.position = movedPath.position.subtract(boundingRect.topLeft);\n    var precision = 3;\n    let paper_path_string = \"\";\n    for (let s of movedPath.segments) {\n        paper_path_string += s.point.x.toFixed(precision) + \" \" + s.point.y.toFixed(precision) + \" \" + s.handleIn.x.toFixed(precision) + \" \" + s.handleIn.y.toFixed(precision) + \" \" + s.handleOut.x.toFixed(precision) + \" \" + s.handleOut.y.toFixed(precision) + \" \";\n    }\n    movedPath.remove();\n    return [boundingRect.topLeft, boundingRect.size, paper_path_string.trim()];\n}\nexport function pathPosSizeCorrection(points) {\n    let posMin = [Number.MAX_VALUE, Number.MAX_VALUE];\n    let posMax = [-Number.MAX_VALUE, -Number.MAX_VALUE];\n    for (let p of points) {\n        posMin[0] = Math.min(posMin[0], p[1]);\n        posMin[1] = Math.min(posMin[1], p[2]);\n        posMax[0] = Math.max(posMax[0], p[1]);\n        posMax[1] = Math.max(posMax[1], p[2]);\n    }\n    let correctedPoints = points.map((p) => { return [p[0], p[1] - posMin[0], p[2] - posMin[1], p[3]] });\n    let width = posMax[0] - posMin[0];\n    let height = posMax[1] - posMin[1];\n    // path pos size\n    return [correctedPoints, posMin, [width, height]];\n}\nexport function paperPathPosSizeCorrection(path) {\n    let points = [];\n    for (let s of segments) {\n        points.push([0, s.point.x, s.point.y, path.strokeWidth]);\n    }\n\n}\n// export function pathChunkPosCorrection(chunk, points) {\n//     return points.map((p) => { return [p[0], p[1] - chunk[0], p[2] - chunk[1], p[3]] });\n// }\nexport function dist(p, q) {\n    return Math.sqrt((p.x - q.x) ** 2 + (p.y - q.y) ** 2);\n}\nexport function parsePoint(string) {\n    let arr = (string || \"0 0\").split(\" \");\n    return new paper.Point(parseFloat(arr[0]), parseFloat(arr[1]));\n}\n\nexport function setAlpha(color, opacity) {\n    // coerce values so ti is between 0 and 1.\n    const _opacity = Math.round(Math.min(Math.max(opacity || 1, 0), 1) * 255);\n    const _opStr = _opacity.toString(16).toUpperCase();\n    if (color.length == 7) {\n        return color + _opStr;\n    } else if (color.length == 9) {\n        color[7] = _opStr[0];\n        color[8] = _opStr[1];\n        return color;\n    }\n}","import { isBoardObjectEvent } from './backend/filter';\nimport { parsePath, parseBezierPath, parsePoint } from './helper';\nexport const paper = require('paper');\nexport default class PaperCanvas {\n    constructor() {\n        this.css_id = \"paper-canvas\";\n        this.displayPaths = [];\n        this.toolLayer = null\n        this.drawLayer = null;\n        this.canvas = null;\n    }\n    drawEvent(event, animated) {\n        let drawC = appData.drawingCanvas;\n        function V1() {\n            if (event.content.objtype != \"p.path\") { return }\n            let updateDisplay = true\n            let points = parsePath(event.content.path, event.content.objpos);\n            let pos = parsePoint(event.content.objpos);\n            let size = parsePoint(event.content.objsize);\n            let color = \"objcolor\" in event.content ? event.content.objcolor : \"#000\"\n            // let strokeWidth = parseFloat(event.content.strokeWidth);\n            if (animated) {\n                drawC.asyncAddPathV1([pos.x, pos.y], points, color);\n            } else {\n                drawC.drawBoundingBox([[pos.x, pos.y], size]);\n                drawC.addPathV1(points, color, [[pos.x, pos.y], size], event.event_id);\n                if (updateDisplay) { drawC.updateDisplay_DEPRECATED(true); }\n            }\n        }\n        function V2() {\n            if (event.content.objtype != \"p.path\") { return }\n            let segments = parseBezierPath(event.content.path, event.content.objpos);\n            // let pos = parsePoint(event.content.objpos);\n            // let size = parsePoint(event.content.objsize);\n            let strokeWidth = parseFloat(event.content.strokeWidth);\n            let closed = (\"closed\" in event.content && event.content.closed)\n            let color = \"objcolor\" in event.content ? event.content.objcolor : \"#000\"\n            let fillColor = \"objFillColor\" in event.content ? event.content.objFillColor : \"#00000000\"\n\n            if (animated) {\n                drawC.asyncAddPathV2(segments, color, fillColor, strokeWidth, closed, event.event_id);\n            } else {\n                // drawC.drawBoundingBox([pos, size]);\n                drawC.addPathV2(segments, color, fillColor, strokeWidth, closed, event.event_id);\n            }\n        }\n        function V3() {\n            switch (event.content.objtype) {\n                case \"path\": {\n                    for (let pathData of event.content.paths) {\n                        let addPathFunc = animated ? drawC.asyncAddPathV3 : drawC.addPathV3\n                        addPathFunc(pathData, event.event_id)\n                    }\n                }\n            }\n        }\n\n        if (!(\"version\" in event.content)) {\n            V1(); return\n        }\n        switch (event.content.version) {\n            case 1: V1()\n            case 2: V2()\n            case 3: V3()\n        }\n    }\n\n    activateToolLayer() {\n        this.toolLayer.activate()\n    }\n    activateDrawLayer() {\n        this.drawLayer.activate();\n    }\n    init() {\n        // Get a reference to the canvas object\n        this.canvas = document.getElementById('paper-canvas');\n        // Create an empty project and a view for the canvas:\n        paper.setup(this.canvas);\n        paper.install(window)\n        this.drawLayer = paper.project.activeLayer;\n        this.toolLayer = new paper.Layer()\n    }\n    offset(offset_delta) {\n        paper.view.center = paper.view.center.subtract(offset_delta);\n    }\n    resetOffset() {\n        this.setOffset(new paper.Point(0, 0));\n    }\n    setOffset(offset) {\n        paper.view.center = offset;\n    }\n    getZoom() {\n        return paper.view.zoom;\n    }\n    zoom(factor, zoomOrigin) {\n        if (zoomOrigin === null) {\n            paper.view.scale(factor)\n        } else {\n            let zoomOriProj = paper.view.viewToProject(zoomOrigin);\n            paper.view.scale(factor, zoomOriProj);\n        }\n    }\n    setZoom(zoom, zoomOrigin = paper.view.center) {\n        let currentViewCenter = paper.view.center;\n        let zoomOriProj = paper.view.viewToProject(zoomOrigin);\n        paper.view.center = zoomOriProj;\n        let scale = paper.view.zoom;\n        paper.view.zoom = zoom;\n        paper.view.center = currentViewCenter;\n    }\n    resetZoom() {\n        this.setZoom(1);\n    }\n    asyncAddPathV1() {\n        console.log(\"WAIT WHAT???\")\n    }\n    asyncAddPathV2(segments, color, fillColor, strokeWidth, closed = false, id = \"\") {\n        // TODO make async animation using dash\n        let p = appData.drawingCanvas.addPathV2(segments, color, fillColor, strokeWidth, closed, id);\n        let length = 0;\n        length = p.length;\n        p.dashArray = [length, length];\n        // TODO dont hardcode the speed. instead get it from the event\n        // \"drawSpeed\": \"20 50 50 20 12\"\n        // 20ms for the first 50 px length, 50 ms for the second px length...\n        p.tween({ dashOffset: length }, { dashOffset: 0 }, 2 * length).then(() => {\n            p.dashArray = []\n        })\n        // p.tween({ dashArray: [10, 10] }, { dashArray: [1000, 10] }, 3000);\n    }\n    asyncAddPathV3(pdat, id) {\n        let p = appData.drawingCanvas.addPathV3(pdat, id);\n        let l = p.length;\n        p.dashArray = [l, l];\n        p.tween({ dashOffset: l }, { dashOffset: 0 }, 2 * l).then(() => {\n            p.dashArray = []\n        })\n        return p;\n    }\n    addPathV3(pdat, id) {\n        let segments = pdat.segments.map((seg) => {\n            let s = seg.split(\" \");\n            return new Segment(new Point(parseFloat(s[0]), parseFloat(s[1])),\n                new Point(parseFloat(s[2]), parseFloat(s[3])),\n                new Point(parseFloat(s[4]), parseFloat(s[5])))\n        }\n        );\n        let p = new paper.Path(segments);\n        p.strokeColor = pdat.strokeColor;\n        p.fillColor = pdat.fillColor;\n        p.strokeWidth = pdat.strokeWidth;\n        p.closed = pdat.closed;\n        p.position = p.position.add(new Point(parseFloat(pdat.position.x), parseFloat(pdat.position.y)))\n        p.strokeCap = \"round\";\n        if (id != \"\") {\n            p.data.id = id\n        }\n        return p;\n    }\n\n    addPathV2(segments, color, fillColor, strokeWidth, closed = false, id = \"\") {\n        let p = new paper.Path(segments);\n        p.strokeColor = color;\n        // if (fillColor != \"#00000000\") { p.fillColor = fillColor; }\n        p.fillColor = fillColor;\n\n        p.strokeWidth = strokeWidth;\n        p.strokeCap = \"round\";\n        p.closed = closed;\n        if (id != \"\") {\n            p.data.id = id\n        }\n        return p;\n        // p.moveTo(new paper.Point(points[0][1], points[0][2]));\n        // for (let i = 1; i < points.length; i++) {\n        //     p.lineTo(new paper.Point(points[i][1], points[i][2]));\n        // }\n    }\n    addPathV1(points, color, [pos, size], id = \"\") {\n        let p = new paper.Path();\n        p.strokeColor = color;\n        p.strokeWidth = 2;\n        p.strokeCap = \"round\";\n        if (id != \"\") {\n            p.data.id = id\n        }\n        p.moveTo(new paper.Point(points[0][1], points[0][2]));\n        for (let i = 1; i < points.length; i++) {\n            p.lineTo(new paper.Point(points[i][1], points[i][2]));\n        }\n    }\n    updateDisplay_DEPRECATED() {\n        if (this.dispPath !== null) {\n            // this.dispPath.remove();\n            this.displayPaths.push(this.dispPath);\n            this.dispPath = null;\n        }\n        // for(p of this.displayPaths){\n        //     p.remove();\n        // }\n    }\n    // TODO call this function in a moment where ne drawing animaiotn is running\n    clearDisplayPaths() {\n        this.displayPaths.forEach((p) => { p.remove() });\n    }\n    clear() {\n        let length = 0;// = paper.project.activeLayer.removeChildren();\n        for (let l of paper.project.layers) {\n            if (l === this.toolLayer) {\n                continue\n            }\n            length += l.removeChildren().length;\n        }\n        console.log(\"removed \", length, \" items\")\n    }\n    drawBoundingBox(box) {\n        // console.log(\"drawBoundingBox not implemented for paper-canvas\")\n    }\n    reload(animated = false) {\n        this.clear();\n        let starttime = Date.now();\n        console.log(\"!! Paper Canvas redraw START\");\n        appData.objectStore.allSorted().forEach(obj => {\n            if (isBoardObjectEvent(obj.type)) {\n                this.drawEvent(obj, animated);\n            }\n        });\n        console.log(\"!! Paper Canvas redraw DONE in\", Date.now() - starttime);\n    }\n    getTransformedPointer(x, y) {\n        return paper.view.viewToProject(new paper.Point(x, y))\n    }\n}\n\n\nconst sleep = ms => {\n    return new Promise(resolve => setTimeout(resolve, ms))\n}\n\nfunction drawGrid(ctx, grid, size, gridsize, color) {\n    ctx.fillStyle = color;\n    ctx.strokeStyle = color;\n    ctx.lineWidth = 2;\n    if (grid === \"dots\") {\n        let radius = 3;\n        let xcount = size[0] / gridsize;\n        let ycount = size[1] / gridsize;\n        ctx.beginPath();\n        for (let i = 0; i < xcount; i++) {\n            for (let j = 0; j < ycount; j++) {\n                ctx.moveTo(i * gridsize, j * gridsize);\n                ctx.ellipse(i * gridsize, j * gridsize, radius, radius, 0, 0, Math.PI * 2);\n            }\n        }\n        ctx.fill();\n    }\n    if (grid === \"squares\") {\n        let xcount = size[0] / gridsize;\n        let ycount = size[1] / gridsize;\n        ctx.beginPath();\n        for (let i = 0; i < xcount; i++) {\n            ctx.moveTo(i * gridsize, 0);\n            ctx.lineTo(i * gridsize, size[1]);\n        }\n        for (let j = 0; j < ycount; j++) {\n            ctx.moveTo(0, j * gridsize);\n            ctx.lineTo(size[0], j * gridsize);\n        }\n        ctx.stroke();\n    }\n}","var _tool_stroke_width_index = 1\nvar TOOL_STROKE_WIDTH_OPTION_COUNT = 4\nexport default function init_line_style_selector(){\n    let button = document.getElementById(\"line-type-selector-button\")\n    button.onclick = function (btnEv) {\n        _tool_stroke_width_index += 1;\n        _tool_stroke_width_index = _tool_stroke_width_index % TOOL_STROKE_WIDTH_OPTION_COUNT\n        updateVisiblePreviewItem()\n    }\n    function updateVisiblePreviewItem() {\n        let previewItems = document.querySelectorAll(\"#line-type-selector-button div\");\n        for (let i = 0; i < TOOL_STROKE_WIDTH_OPTION_COUNT; i++) {\n            if (i == _tool_stroke_width_index) {\n                previewItems[i].style.display = \"block\"\n            } else {\n                previewItems[i].style.display = \"none\"\n            }\n        }\n    }\n    updateVisiblePreviewItem(1);\n}\nexport function GetToolStrokeWidthIndex() {\n    return _tool_stroke_width_index;\n}","// TODO: think about this appraoch... maybe store the color picker instance in main...\n// const paper = require('paper')\nimport {paper} from './paper-canvas'\n\nlet colorPickerSvg;\nexport function init_color_picker() {\n    colorPickerSvg = new ColorPicker();\n    colorPickerSvg.selectColor([1, 0])\n}\nexport function GetPickerColor(){\n    return colorPickerSvg.getColor().toCSS(true)\n}\nexport function SetColorPalette(palette){\n    colorPickerSvg.setColorPalette(palette)\n}\nexport class ColorPicker {\n\n    constructor() {\n        // this.colors = [\"#999\", \"#FEB326\", \"#7F58AF\"]//,\"#8ae234\"\n        // this.colors = [\"#999\", \"#64C5EB\", \"#8ae234\", \"#E84D8A\", \"#FEB326\", \"#7F58AF\"]//,\n        this.colors = [\"#999\",  \"#8ae234\", \"#ef2929\", \"#fcaf3e\", \"#729fcf\",\"#ad7fa8\"]//,\n        this.darkColors = this.colors.map((c) => { return new paper.Color(c).multiply(0.7) });\n        this.darkColors[0] = 'black'\n        this.outline = null;\n        this.colorPaths = [[], []]\n        this.selectedColor = [0, 0];\n        this.COLOR_PICKER_BORDER = 20;\n        this.innerCircle = 0.35\n        this.middleCircle = 0.7\n\n        this.project = new paper.Project(\"color-picker-canvas\");\n        this.redraw();\n    }\n    redraw(){\n        this.project.activate();\n        let el = document.getElementById('color-picker-canvas');\n        let size = paper.view.size;\n        let cent = new paper.Point(size.divide(2));\n        let radi = size.width / 2 - this.COLOR_PICKER_BORDER;\n        let circleBg = new paper.Path.Circle(cent, radi);\n        circleBg.shadowBlur = this.COLOR_PICKER_BORDER;\n        circleBg.shadowColor = 'grey';\n        circleBg.fillColor = 'white';\n        this.colorPaths[0] = this.create_segment_ring(this.colors, cent, radi * this.middleCircle - 1, radi, 0);\n        this.colorPaths[1] = this.create_segment_ring(this.darkColors, cent, radi * this.innerCircle, radi * this.middleCircle, 1);\n\n        let circleInner = new paper.Path.Circle(cent, this.innerCircle * radi);\n        circleInner.shadowBlur = this.COLOR_PICKER_BORDER;\n        circleInner.shadowColor = '#444';\n        circleInner.fillColor = 'white';\n\n        paper.projects[0].activate();\n    }\n    setColorPalette(palette){\n        this.colors = [\"#999\"].concat(palette);\n        this.darkColors = this.colors.map((c) => { return new paper.Color(c).multiply(0.7) });\n        this.darkColors[0] = 'black'\n        this.redraw()\n    }\n    create_segment_ring(colors, center, innerRad, outerRad, index) {\n        let count = colors.length;\n        let offset = Math.PI / count;\n        let paths = [];\n        for (let i = 0; i < count; i++) {\n            let deg = Math.PI * 2 / count * i - offset;\n            let deg2 = Math.PI * 2 / count * (i + 1) - offset\n            let p = this.create_segment(center, innerRad, outerRad, deg, deg2);\n            p.fillColor = colors[i]\n            p.onMouseDown = function (e) {\n                colorPickerSvg.selectColor([index, i])\n            }\n            paths.push(p);\n        }\n        return paths;\n    }\n    create_segment(center, innerRad, outerRad, startDeg, endDeg) {\n        function getPointFromDeg(deg, center, rad) {\n            let x = Math.sin(deg) * rad;\n            let y = -Math.cos(deg) * rad;\n            return center.add(new paper.Point(x, y));\n        }\n\n        let p = new paper.Path();\n        let middleDeg = (startDeg + endDeg) / 2;\n        p.moveTo(getPointFromDeg(startDeg, center, outerRad));\n        p.arcTo(getPointFromDeg(middleDeg, center, outerRad), getPointFromDeg(endDeg, center, outerRad));\n        p.lineTo(getPointFromDeg(endDeg, center, innerRad));\n        p.arcTo(getPointFromDeg(middleDeg, center, innerRad), getPointFromDeg(startDeg, center, innerRad));\n        p.closePath();\n        return p;\n    }\n\n    selectColor(index_arr) {\n        this.selectedColor = index_arr\n        let path = this.colorPaths[index_arr[0]][index_arr[1]];\n        if (this.outline !== null) {\n            this.outline.remove();\n            // let seg = path.segments.slice();\n            // this.outline.tween({segments:seg},1000)\n        }\n        this.outline = path.clone();\n        this.outline.fillColor = \"#FFFFFF00\"\n        this.outline.strokeWidth = 4;\n        this.outline.bringToFront();\n        this.outline.strokeColor = 'white';\n    }\n    getColor() {\n        let path = this.colorPaths[this.selectedColor[0]][this.selectedColor[1]];\n        return path.fillColor;\n    }\n}","// import { drawingCanvas } from \"../drawing\";\nimport PaperCanvas from \"../paper-canvas\";\n// import { sendPath } from \"../actions\";\n// import { objectStore, currentRoomId,drawingCanvas } from \"../main\";\n// import { matrixClient } from '../main'//backend;\nimport { GetToolStrokeWidthIndex } from \"./line-style-selector\";\nimport { GetPickerColor } from \"../color-picker\";\nimport { mousePathToString, paperPathToString, pathPosSizeCorrection, setAlpha } from \"../helper\";\nexport default class ToolPen {\n    constructor(marker = false) {\n        this.isMarker = marker\n\n        // Tool state\n        this.mouse_path = [];\n        this.mouse_path_last_time = Date.now();\n        this.last_pos = []\n        this.tool_canceled = false;\n\n        // Tool settings\n        this.strokeWidthOptions = [1, 2, 4, 8];\n\n        this.previewItem = null;\n\n        this.previewPaths = [];\n        this.previewPathTween = null;\n    }\n    getStrokeWidth() {\n        return this.strokeWidthOptions[GetToolStrokeWidthIndex()] * (this.isMarker ? 10 : 1);\n    }\n    getStrokeColor() {\n        return this.isMarker ? setAlpha(GetPickerColor(), 0.1) : GetPickerColor();\n    }\n    tooldown(proX, proY, pressure) {\n        this.tool_canceled = false;\n\n        this.mouse_path_start_time = Date.now();\n        this.last_pos = [0, proX, proY, pressure];\n        this.mouse_path = [[0, proX, proY, pressure * 4]];\n\n        appData.drawingCanvas.activateToolLayer()\n        for (let path of this.previewPaths) {\n            if (!path.visible) {\n                path.remove()\n            }\n        }\n        this.previewPaths.filter((path) => { path.visible })\n\n        let prev = new Path();\n        this.previewPaths.push(prev);\n\n        let colorAlpha = new Color(this.getStrokeColor());\n        colorAlpha.alpha = colorAlpha.alpha * 0.8;\n        prev.strokeColor = colorAlpha;\n        prev.strokeWidth = this.getStrokeWidth();\n        prev.strokeCap = \"round\"\n        prev.moveTo(new Point(proX, proY))\n        appData.drawingCanvas.activateDrawLayer()\n\n        console.log(\"tooldown\");\n    }\n    toolmove(proX, proY, pressure) {\n        console.log(\"toolmove\");\n        // no pressure for now\n        pressure = 1;\n        let x = proX;\n        let y = proY;\n        let time_delta = Math.min(80, Date.now() - this.mouse_path_last_time);\n        let thickness_factor = 1\n        this.mouse_path_last_time = Date.now();\n\n        let currentPos = [time_delta, x, y, (pressure * 2 + Math.min(3, Math.max(0.0, thickness_factor)))];\n        let dist = (currentPos[1] - this.last_pos[1]) ** 2 + (currentPos[2] - this.last_pos[2]) ** 2\n\n        // let velocity = dist / Math.max(1, time_delta);\n        // let thickness_factor = 1.5 - velocity / 8.0;\n        // todo fix pressure\n        let currentPosPoint = new Point(currentPos[1], currentPos[2])\n        this.mouse_path.push(currentPos);\n        this.previewPaths[this.previewPaths.length - 1].lineTo(currentPosPoint);\n        this.previewPaths[this.previewPaths.length - 1].smooth()\n        // appData.drawingCanvas.drawSegmentDisplay([this.last_pos, currentPos], this.getStrokeColor(), this.getStrokeWidth());\n        this.last_pos = currentPos;\n\n    }\n    toolpreviewmove(pos) {\n        if (this.previewItem === null) {\n            appData.drawingCanvas.activateToolLayer()\n            this.previewItem = new Path.Circle(new Point(0, 0), 0.5);\n            this.previewItem.applyMatrix = false\n            appData.drawingCanvas.activateDrawLayer()\n        }\n        this.previewItem.scaling = new Point(this.getStrokeWidth(), this.getStrokeWidth())\n        this.previewItem.fillColor = this.getStrokeColor();\n        this.previewItem.position = pos;\n    }\n    toolup(proX, proY) {\n        if (this.tool_canceled) { return; }\n        if (appData.objectStore.hasRoom(appData.matrixClient.currentRoomId)) {\n            if (appData.drawingCanvas instanceof PaperCanvas) {\n                // in mouse path the pressure stroke width is stored. (will be used later to generate a custom path based on that)\n                let paper_mouse_path = this.previewPaths[this.previewPaths.length - 1].clone()//new Path(this.mouse_path.map((s) => { return [s[1], s[2]] }));\n                paper_mouse_path.simplify(1 / appData.drawingCanvas.getZoom());\n                paper_mouse_path.strokeWidth = this.getStrokeWidth();\n                paper_mouse_path.strokeColor = GetPickerColor();\n                appData.matrixClient.sendPath([paper_mouse_path]);\n                paper_mouse_path.remove();\n            }\n        } else {\n            console.log(\"NO ROOM SELECTED TO DRAW IN!\")\n        }\n        this.toolcancel();\n    }\n    toolcancel() {\n        console.log(\"CANCEL\");\n        this.mouse_path = [];\n        this.mouse_path_last_time = Date.now();\n        this.last_pos = []\n        this.tool_canceled = true;\n\n        let prev = this.previewPaths[this.previewPaths.length - 1]\n        let l = prev.length;\n        prev.dashArray = [l, l]\n        prev.tween({ dashOffset: 0 }, { dashOffset: -l }, 2 * l).then((e) => {\n            prev.visible = false\n        });\n    }\n    activate() {\n        if (this.previewItem) {\n            this.previewItem.visible = true;\n        }\n    }\n    deactivate() {\n        if (this.previewItem) {\n            this.previewItem.visible = false;\n        }\n    }\n}","import ToolPen from './tools/tool-pen.js'\nimport ToolEraser from './tools/tool-eraser.js'\nimport ToolLine from './tools/tool-line.js'\nimport ToolRect from './tools/tool-rect.js'\n// import { drawingCanvas } from './main.js'\nimport { dist } from './helper.js'\n\nexport var tools = {\n    \"tool-type-pen\": new ToolPen(),\n    \"tool-type-eraser\": new ToolEraser(),\n    \"tool-type-marker\": new ToolPen(true),\n    \"tool-type-line\": new ToolLine(),\n    \"tool-type-rect\": new ToolRect(),\n    \"tool-type-ellipse\": null,\n    \"tool-type-text\": null,\n    \"tool-type-line-width\": null\n}\nexport var activeTool = tools[\"tool-type-pen\"];\nfunction over_handler(event) { }\nfunction enter_handler(event) { }\n\nvar touchesCache = [];\nvar touchesCacheBegin = [];\nvar touchZoomCache = 0;\nvar touchPanCache = new DOMPoint(0, 0);\nexport function setActiveTool(id){\n    activeTool = tools[id];\n}\nexport default function init_input(element) {\n    var el = element;\n    // POINTER\n    el.onpointerdown = function (e) {\n        // e.preventDefault();\n        console.log(\"onpointerdown\");\n        let project_pt = appData.drawingCanvas.getTransformedPointer(e.offsetX, e.offsetY);\n        if (e.pointerType == \"touch\") {\n            if (touchesCache.length == 0) {\n                activeTool.tooldown(project_pt.x, project_pt.y, e.pressure);\n            } else {\n                activeTool.toolcancel();\n                touchZoomCache = appData.drawingCanvas.getZoom();\n            }\n            touchesCacheBegin.push(e);\n            touchesCache.push(e);\n        } else {\n            // let project_pt = appData.drawingCanvas.getTransformedPointer(e.offsetX, e.offsetY);\n            activeTool.tooldown(project_pt.x, project_pt.y, e.pressure);\n        }\n    };\n    el.onpointermove = function (e) {\n        // e.preventDefault()\n        // console.log(\"onpointermove\");\n        if ((e.buttons == 1 && (e.pointerType == \"mouse\" || e.pointerType == \"pen\"))\n            || (e.pointerType == 'touch' && touchesCache.length < 2)) {\n            let project_pt = appData.drawingCanvas.getTransformedPointer(e.offsetX, e.offsetY);\n            activeTool.toolmove(project_pt.x, project_pt.y, e.pressure);\n        } else if (e.buttons == 4 && (e.pointerType == \"mouse\" || e.pointerType == \"pen\")) {\n            let offset = new paper.Point(e.movementX, e.movementY)\n            appData.drawingCanvas.offset(offset.divide(appData.drawingCanvas.getZoom()));\n        }\n        else if (touchesCache.length == 2 && e.pointerType == \"touch\") {\n            let index = touchesCache.findIndex((el) => { return e.pointerId === el.pointerId });\n            touchesCache[index] = e;\n            handlePanZoom();\n        }\n        activeTool.toolpreviewmove(appData.drawingCanvas.getTransformedPointer(e.offsetX, e.offsetY))\n    };\n    el.onpointerup = function (e) {\n        console.log(\"onpointerup\");\n        let project_pt = appData.drawingCanvas.getTransformedPointer(e.offsetX, e.offsetY);\n        if (e.pointerType == \"touch\") {\n            touchesCache = touchesCache.filter((cache_event) => { cache_event.pointerId == e.pointerId });\n            touchesCacheBegin = touchesCacheBegin.filter((cache_event) => { cache_event.pointerId == e.pointerId });\n            touchPanCache = new DOMPoint(0, 0);\n            handleTouchType = \"\";\n            touchZoomCache = 0;\n            if (!activeTool.tool_canceled) {\n                activeTool.toolup(project_pt.x, project_pt.y, e.pressure);\n            }\n        } else {\n            activeTool.toolup(project_pt.x, project_pt.y, e.pressure);\n        }\n    };\n\n    // WHEEL\n    el.onwheel = function (e) {\n        e.preventDefault();\n        if (e.ctrlKey) {\n            //ctrl is used as the indicator for pinch gestures... (Not a fan...)\n            zoom(e.offsetX, e.offsetY, 1 + e.wheelDeltaY);\n        } else {\n            let scroll_speed = 0.5;\n            let offset = new paper.Point(e.wheelDeltaX * scroll_speed, e.wheelDeltaY * scroll_speed);\n            appData.drawingCanvas.offset(offset.divide(appData.drawingCanvas.getZoom()));\n        }\n    };\n    // unused\n    el.onpointerover = over_handler;\n    el.onpointerenter = enter_handler;\n    // el.onpointercancel = cancel_handler;\n    // el.onpointerout = out_handler;\n    // el.onpointerleave = leave_handler;\n    // el.gotpointercapture = gotcapture_handler;\n    // el.lostpointercapture = lostcapture_handler;\n    // el.ontouchend = (e) => {\n    //     // e.preventDefault();\n    // };\n    el.addEventListener(\"touchstart\", (e) => {\n        e.preventDefault();\n    }, { passive: false });\n    el.addEventListener(\"gesturestart\", (e) => {\n        e.preventDefault();\n    }, { passive: false });\n    // el.ontouchstart = (e) => {\n    //     e.preventDefault();\n    // };\n    // el.ontouchmove = (e) => {\n    //     // e.preventDefault();\n    // };\n}\n\n\nfunction scroll(deltaX, deltaY) {\n    let scroll_speed = 0.5;\n    appData.drawingCanvas.offset(new paper.Point(deltaX * scroll_speed, deltaY * scroll_speed));\n}\nfunction zoom(offsetX, offsetY, factor) {\n    let zoom_speed = 0.004;\n    appData.drawingCanvas.zoom(1 + factor * zoom_speed, new paper.Point(offsetX, offsetY));\n}\nvar touchZoomCache = 0;\nvar touchPanCache = new DOMPoint(0, 0);\nvar handleTouchType = \"\"\nfunction handlePanZoom() {\n    let drawC=appData.drawingCanvas\n    let cx = drawC.canvas.getBoundingClientRect().x;\n    let cy = drawC.canvas.getBoundingClientRect().y;\n    let canvasZoom = drawC.getZoom();\n    let start1 = drawC.getTransformedPointer(touchesCacheBegin[0].clientX - cx, touchesCacheBegin[0].clientY - cy);\n    let start2 = drawC.getTransformedPointer(touchesCacheBegin[1].clientX - cx, touchesCacheBegin[1].clientY - cy);\n    let current1 = drawC.getTransformedPointer(touchesCache[0].clientX - cx, touchesCache[0].clientY - cy);\n    let current2 = drawC.getTransformedPointer(touchesCache[1].clientX - cx, touchesCache[1].clientY - cy);\n    var PINCH_THRESHOLD = 70 //drawC.canvas.clientWidth / 40;\n    var PAN_THRESHOLD = 40\n    var distStart = dist(start1, start2);\n    var distCurrent = dist(current1, current2);\n    var currentCenter = current1.add(current2).multiply(0.5); //new paper.Point((current1.x + current2.x) / 2, (current1.y + current2.y) / 2)\n    var startCenter = start1.add(start2).multiply(0.5); //[(start1.x + start2.x) / 2, (start1.y + start2.y) / 2]\n    var panDistDelta = dist(currentCenter, startCenter) * canvasZoom;\n    var pinchDistDelta = Math.abs(distStart - distCurrent) * canvasZoom;\n    // console.log(\"pinch Dist: \", panDistDelta)\n    // console.log(\"pan Dist: \", pinchDistDelta)\n    if (pinchDistDelta < PINCH_THRESHOLD && panDistDelta < PAN_THRESHOLD) {\n        return\n    }\n    if (handleTouchType == \"\") {\n        handleTouchType = pinchDistDelta > panDistDelta ? \"pinch\" : \"pan\"\n    }\n    if (handleTouchType == \"pinch\") {\n        // Zoom\n        var currentZoomFactor = distCurrent / distStart;\n        // console.log(\"zoomFactor: \", currentZoomFactor);\n        //TODO some log or exp to make absolute zoom... Maybe not. feels just fine as it is...\n        drawC.setZoom(touchZoomCache * currentZoomFactor, startCenter);\n        // touchZoomCache = distCurrent / distStart;\n    }\n    if (handleTouchType == \"pan\") {\n        // Pan\n        var offset = startCenter.subtract(currentCenter) //new DOMPoint(startCenter[0] - currentCenter[0], startCenter[1] - currentCenter[1]);\n        // console.log(\"offset: \", offset);\n        var offsetDiff = new paper.Point(touchPanCache.x - offset.x, touchPanCache.y - offset.y);\n        touchPanCache = offset;\n        // console.log(\"offsetDiff: \", offsetDiff, drawC.getZoom());\n        // multipy with zoom\n        drawC.offset(offsetDiff);\n    }\n}\n","// import {  } from \"../drawing\";\n// import { objectStore } from '../main'\n// import { sleep } from './paper-canvas';\nimport { GetToolStrokeWidthIndex } from \"./line-style-selector\";\nimport { mousePathToString, paperPathToString, pathPosSizeCorrection, setAlpha } from \"../helper\";\n\n\nexport default class ToolEraser {\n    constructor() {\n\n        // Tool state\n        this.removedElementsArray\n        this.tool_canceled = false\n        this.idsToDelete = []\n\n        // Tool settings\n        // this.strokeWidth = 10;\n        this.strokeWidthOptions = [5, 10, 20, 40];\n\n        // Preview\n        this.previewItem = null\n\n    }\n\n    getStrokeWidth() {\n        return this.strokeWidthOptions[GetToolStrokeWidthIndex()];\n    }\n    tooldown(proX, proY, pressure) {\n        this.tool_canceled = false;\n        this.addItemsFromPoint(new paper.Point(proX, proY))\n        console.log(\"tooldown\");\n    }\n    toolmove(proX, proY, pressure) {\n        console.log(\"toolmove\");\n        this.addItemsFromPoint(new paper.Point(proX, proY))\n    }\n    addItemsFromPoint(testPoint) {\n        var hitOptions = {\n            stroke: true,\n            tolerance: this.getStrokeWidth(),\n            match: function (hitRes) {\n                return !(\"markedForDeletion\" in hitRes.item.data)\n                    && (\"id\" in hitRes.item.data)\n            }\n        };\n\n        var hitResult = paper.project.hitTest(testPoint, hitOptions);\n        var i = 0;\n        while (hitResult && i < 10) {\n            if (!hitResult) { continue }\n            console.log('hitResult', hitResult);\n            if (appData.objectStore.getById(hitResult.item.data.id).sender == appData.matrixClient.client.getUserId()) {\n                hitResult.item.opacity = 0.5;\n                hitResult.item.data.markedForDeletion = true\n                this.idsToDelete.push(hitResult.item.data.id)\n                hitResult = paper.project.hitTest(testPoint, hitOptions);\n            }\n            i++;\n        }\n    }\n    toolup(proX, proY) {\n        if (this.tool_canceled) { return; }\n\n        this.toolcancel();\n\n        console.log(this.idsToDelete)\n        for (let id of this.idsToDelete) {\n            console.log(id)\n            appData.matrixClient.client.redactEvent(appData.matrixClient.currentRoomId, id).then(t => {\n                console.log(\"redacted (eraser): \", t);\n            });\n            this.idsToDelete = this.idsToDelete.filter((itemId) => { return itemId == id })\n            // await sleep(300);\n        }\n        this.idsToDelete = [];\n\n    }\n    toolcancel() {\n        console.log(\"CANCEL\");\n        this.tool_canceled = true;\n    }\n    toolpreviewmove(pos) {\n        if (this.previewItem === null) {\n            appData.drawingCanvas.activateToolLayer()\n            this.previewItem = new paper.Path.Circle(new paper.Point(0, 0), 1);\n            this.previewItem.fillColor = '#00000000'\n            this.previewItem.strokeWidth = 1\n            this.previewItem.strokeColor = '#999'\n            this.previewItem.dashArray = [3, 3]\n            this.previewItem.strokeCap = 'round'\n            // this.previewItem.applyMatrix = false\n            // this.previewItem.scaling = new paper.Point(this.getStrokeWidth(), this.getStrokeWidth())\n            appData.drawingCanvas.activateDrawLayer()\n        }\n        if (this.previewItem.bounds.size.width != 2 * this.getStrokeWidth()) {\n            let w = 2 * this.getStrokeWidth() / this.previewItem.bounds.size.width\n            this.previewItem.scaling = new paper.Point(w, w)\n        }\n        this.previewItem.position = pos;\n    }\n    activate() {\n        if (this.previewItem) {\n            this.previewItem.visible = true\n        }\n    }\n    deactivate() {\n        this.previewItem.visible = false\n    }\n}","// import { drawingCanvas } from \"../drawing\";\n// import { sendPath } from \"../actions\";\n// import { objectStore, currentRoomId,drawingCanvas } from '../main'\n// import { matrixClient } from '../main'//backend;\nimport { GetPickerColor } from \"../color-picker\";\n// import { Path, Color, Point } from \"paper/dist/paper-core\";\nimport { GetToolStrokeWidthIndex } from \"./line-style-selector\";\nimport { mousePathToString, paperPathToString, pathPosSizeCorrection, setAlpha } from \"../helper\";\n\n\nexport default class ToolLine {\n    constructor() {\n\n        // Tool state\n        this.canvas_line = null;\n        // this.mouse_path_last_time = Date.now();\n        // this.last_pos = []\n        this.tool_canceled = true;\n\n        // Tool settings\n        // this.strokeWidth = 2;\n        this.strokeWidthOptions = [1, 2, 4, 8];\n    }\n    getStrokeWidth() {\n        return this.strokeWidthOptions[GetToolStrokeWidthIndex()];\n    }\n    tooldown(proX, proY, pressure) {\n        this.tool_canceled = false;\n        let pt = new paper.Point(proX, proY);\n        this.canvas_line = new paper.Path([pt, pt])\n        let colorAlpha = setAlpha(GetPickerColor(), 0.3);\n        this.canvas_line.strokeColor = colorAlpha;\n        this.canvas_line.strokeWidth = this.getStrokeWidth();\n        this.canvas_line.strokeCap = \"round\"\n        // this.mouse_path_start_time = Date.now();\n        // this.last_pos = [0, pt.x, pt.y, pressure];\n        // this.mouse_path = [[0, pt.x, pt.y, pressure * 4]];\n        console.log(\"tooldown\");\n    }\n    toolmove(proX, proY, pressure) {\n        console.log(\"toolmove\");\n        this.canvas_line.lastSegment.point = new paper.Point(proX, proY);\n    }\n\n    toolup(proX, proY) {\n        if (this.tool_canceled) { return; }\n        if (appData.objectStore.hasRoom(appData.matrixClient.currentRoomId)) {\n            // let [corrected_mouse_path, pos, size] = pathPosSizeCorrection([[0,this.canvas_line.firstSegment.point.x,this.canvas_line.firstSegment.point.y,0],[0,this.canvas_line.lastSegment.point.x,this.canvas_line.lastSegment.point.y,0]]);\n\n            // let paper_mouse_path = new paper.Path(corrected_mouse_path.map((s) => { return [s[1], s[2]] }));\n\n            // let [pos, size, string_path] = paperPathToString(this.canvas_line);\n            // paper_mouse_path.remove();\n            // let version = 2;\n            // sendPath(appData.matrixClient.client, appData.matrixClient.currentRoomId,\n            //     string_path,\n            //     GetPickerColor(),'#00000000', [pos.x,pos.y], [size.width,size.height], this.getStrokeWidth(), false, version);\n            this.canvas_line.strokeWidth = this.getStrokeWidth();\n            this.canvas_line.strokeColor = GetPickerColor();\n            appData.matrixClient.sendPath([this.canvas_line]);\n        } else {\n            console.log(\"NO ROOM SELECTED TO DRAW IN!\")\n        }\n        this.toolcancel();\n    }\n    toolcancel() {\n        console.log(\"CANCEL\");\n        if (this.canvas_line !== null) {\n            this.canvas_line.remove();\n        }\n        this.canvas_line = null;\n        this.tool_canceled = true;\n    }\n    toolpreviewmove(pos) { }\n    activate() { }\n    deactivate() { }\n}","// import { drawingCanvas } from \"../drawing\";\n// import { Path, Color, Point } from \"paper/dist/paper-core\";\nimport { GetPickerColor } from \"../color-picker\";\nimport { GetToolStrokeWidthIndex } from \"./line-style-selector\";\n// import { sendPath } from \"../actions\";\n// import { objectStore, currentRoomId, drawingCanvas} from \"../main\";\n// import { matrixClient } from '../main'//backend;\nimport { mousePathToString, paperPathToString, pathPosSizeCorrection, setAlpha } from \"../helper\";\n\nexport default class ToolRect {\n    constructor() {\n\n        // Tool state\n        this.canvas_rect = null;\n\n        // Tool settings\n        this.strokeWidthOptions = [1, 2, 4,8];\n    }\n    getStrokeWidth(){\n        return this.strokeWidthOptions[GetToolStrokeWidthIndex()];\n    }\n\n    tooldown(proX, proY, pressure) {\n        this.tool_canceled = false;\n        let pt = new paper.Point(proX, proY);\n        appData.drawingCanvas.activateToolLayer();\n        this.canvas_rect = new paper.Path.Rectangle(pt, pt)\n        let colorAlpha = setAlpha(GetPickerColor(), 0.3);\n        this.canvas_rect.strokeColor = colorAlpha;\n        this.canvas_rect.strokeWidth = this.getStrokeWidth();\n        this.canvas_rect.strokeCap = \"round\"\n        // this.mouse_path_start_time = Date.now();\n        // this.last_pos = [0, pt.x, pt.y, pressure];\n        // this.mouse_path = [[0, pt.x, pt.y, pressure * 4]];\n        appData.drawingCanvas.activateDrawLayer();\n        console.log(\"tooldown\");\n    }\n    toolmove(proX, proY, pressure) {\n        console.log(\"toolmove\");\n        this.canvas_rect.segments[1].point.x = proX\n        this.canvas_rect.segments[2].point = new paper.Point(proX, proY)\n        this.canvas_rect.segments[3].point.y = proY\n    }\n\n    toolup(proX, proY) {\n        if (this.tool_canceled) { return; }\n        if (appData.objectStore.hasRoom(appData.matrixClient.currentRoomId)) {\n            // let [corrected_mouse_path, pos, size] = pathPosSizeCorrection([[0,this.canvas_rect.firstSegment.point.x,this.canvas_rect.firstSegment.point.y,0],[0,this.canvas_rect.lastSegment.point.x,this.canvas_rect.lastSegment.point.y,0]]);\n\n            // let paper_mouse_path = new paper.Path(corrected_mouse_path.map((s) => { return [s[1], s[2]] }));\n\n            // let [pos, size, string_path] = paperPathToString(this.canvas_rect);\n            // paper_mouse_path.remove();\n            // let version = 2;\n            let colorAlpha = new Color(GetPickerColor());\n            colorAlpha.alpha = 0.08;\n            let cA = setAlpha(GetPickerColor(), 0.08);\n            this.canvas_rect.fillColor = colorAlpha;// setAlpha(GetPickerColor(), 0.08);\n            this.canvas_rect.strokeColor = GetPickerColor();\n            appData.matrixClient.sendPath([this.canvas_rect]);\n\n            // sendPath(appData.matrixClient.client, appData.matrixClient.currentRoomId,\n            //     string_path,\n            //     GetPickerColor(), setAlpha(GetPickerColor(), 0.08),[pos.x, pos.y], [size.width, size.height], this.getStrokeWidth(), true, version);\n        } else {\n            console.log(\"NO ROOM SELECTED TO DRAW IN!\")\n            appData.drawingCanvas.updateDisplay_DEPRECATED();\n        }\n        this.toolcancel();\n    }\n    toolcancel() {\n        console.log(\"CANCEL\");\n        if (this.canvas_rect !== null) {\n            this.canvas_rect.remove();\n            this.canvas_rect = null;\n            this.tool_canceled = true;\n        }\n    }\n    toolpreviewmove(pos){}\n    activate(){}\n    deactivate(){}\n}","export default class NotebookTree {\n    constructor() {\n        this.notebooks = {}\n        this.whiteboards = []\n    }\n    clear() {\n        this.notebooks = {}\n        this.whiteboards = []\n    }\n}","import { hideLoading, showLoading } from \"../main\";\nimport { AutoDiscovery } from \"matrix-js-sdk\";\n\nconst loginContainerTemplate = document.createElement('template');\nloginContainerTemplate.innerHTML = /*html*/`\n<link href=\"style.css\" rel=\"stylesheet\" type=\"text/css\">\n<style>\n    span {\n        font-size: 3em;\n        white-space: pre;\n        font-weight: 100;\n    }\n    input {\n        width: 100%;\n        padding: 12px 20px;\n        margin: 8px 0;\n        display: inline-block;\n        border: 1px solid #ccc;\n        border-radius: 4px;\n        box-sizing: border-box;\n    }\n    button.submit {\n        width: 100%;\n        background-color: #FFAF50;\n        background-color: #4CAF50;\n        color: white;\n        padding: 14px 20px;\n        margin: 8px 0;\n        border: none;\n        border-radius: 4px;\n        cursor: pointer;\n    }\n</style>\n<div class='center-container' id='login-container'>\n    <p>\n        <span>The Board</span>\n        <span style='font-size: 1em;'> (alpha `+process.env.PACKAGE_VERSION+ /*html*/`)</span>\n    </p>\n    <form action=\"javascript:void(0);\" onsubmit=\"()=>{return false;}\">\n    <label for='username'>Username:</label><br>\n    <input type='text' id='username' name='username' autocomplete=\"username\" placeholder='Your matrix id...'><br>\n    <label for='password'>Password:</label><br>\n    <input type='password' id='password' name='password' autocomplete=\"current-password\" placeholder='your password...'><br>\n    <button id='login-submit' class='submit'>Log in</button>\n    </form>\n    <label for='server'>Server:</label><br>\n    <input type='text' id='server-url' name='server' placeholder='Server url'><br>\n</div>\n`\nexport class LoginContainer extends HTMLElement {\n    constructor() {\n        super();\n    }\n    checkUsername(username) {\n        let re = new RegExp(\"@[a-zA-Z0-9_.+-]+\\\\:[a-zA-Z0-9-]+\\\\.[a-zA-Z0-9-.]+$\")\n        if (re.test(username)) {\n            let serverDomain = username.split(\":\")[1];\n            showLoading(\"Getting homeserver Information for domain \" + serverDomain);\n            AutoDiscovery.findClientConfig(serverDomain)\n                .then((clientConf) => {\n                    hideLoading();\n                    let baseUrl = clientConf[\"m.homeserver\"].base_url;\n                    if (baseUrl) {\n                        this.shadowRoot.querySelector(\"#server-url\").value = baseUrl;\n                    }\n                })\n            return true\n        }\n        return false\n    }\n    hide() {\n        let login = this.shadowRoot.querySelector(\"#login-container\");\n        login.style.display = \"none\"\n    }\n    loginClicked() {\n\n        function checkpwd(pwd) {\n            console.log(\"pwd to check: \", pwd);\n\n            return pwd.length > 1;\n        }\n        function checkServerUrl(baseUrl) {\n            return baseUrl.length > 5\n        }\n        let baseUrl = this.shadowRoot.querySelector(\"#server-url\").value;\n        let username = this.shadowRoot.querySelector(\"#username\").value;\n        let pwd = this.shadowRoot.querySelector(\"#password\").value;\n\n        console.log(\"username to check: \", username);\n        if (checkpwd(pwd) && this.checkUsername(username) && checkServerUrl(baseUrl)) {\n            appData.matrixClient.login(username, pwd, baseUrl, ()=>{this.hide()});\n        } else {\n            showLoading(\"username or password dont have the correct format\")\n        }\n    }\n\n    connectedCallback() {\n        this.attachShadow({ mode: 'open' });\n        let content = loginContainerTemplate.content;\n        content.getElementById(\"login-submit\").onclick = (ev) => { this.loginClicked() }\n        content.getElementById(\"username\").onchange = (el) => { this.checkUsername(el.target.value) }\n        var pwd_input = content.getElementById(\"password\");\n        pwd_input.addEventListener(\"keypress\", function (event) {\n            if (event.key === \"Enter\") {\n                event.preventDefault();\n                document.getElementById(\"login-submit\").click();\n            }\n        });\n        this.shadowRoot.appendChild(content);\n    }\n}\nif (!customElements.get('login-container')) {\n    customElements.define('login-container', LoginContainer);\n}","import { login, updateAddRoomList } from './main'\n// import { matrixClient } from './main'//backend;\nimport { parsePoint } from './helper'\nimport { isBoardObjectEvent } from './backend/filter'\nimport * as BoardEvent from './backend/board-event-consts'\n\nwindow.actions = {\n    // loginClicked: loginClicked,\n    redactLastAction: redactLastAction,\n    formSubmit: formSubmit,\n    replaceLastEvent: replaceLastEvent,\n    moveLastEvent: moveLastEvent,\n    showAddRoomMenu: showAddRoomMenu,\n    hideAddRoomMenu: hideAddRoomMenu,\n    showSettingsMenu: showSettingsMenu,\n    hideSettingsMenu: hideSettingsMenu,\n    toggleLeftBar: toggleLeftBar\n}\nfunction sendmsgs(amount, client, room) {\n    for (let i = 0; i < amount; i++) {\n        const content = {\n            \"body\": i + \" Test Message\",\n            \"msgtype\": \"m.text\"\n        };\n        client.sendEvent(room, \"m.room.message\", content, \"\", (err, res) => {\n            console.log(err);\n        });\n    }\n}\nfunction toggleGrid() {\n    console.log(setting_grid);\n    if (setting_grid === \"\") {\n        setting_grid = \"squares\";\n    }\n    else if (setting_grid === \"squares\") {\n        setting_grid = \"dots\";\n    }\n    else if (setting_grid === \"dots\") {\n        setting_grid = \"\";\n    }\n    appData.drawingCanvas.reload();\n    // appData.drawingCanvas.updateDisplay_DEPRECATED();\n}\n// function toggleTool() {\n//     if (tool.type === toolType.draw) {\n//         tool.type = toolType.erase;\n//     }\n//     else if (tool.type === toolType.erase) {\n//         tool.type = toolType.draw;\n//     }\n//     // else if (tool === \"mouse\"){\n//     //     tool = \"draw\";\n//     // }\n//     document.getElementById(\"tool\").innerText = \"Tool: \" + tool.getString();\n// }\nfunction redactLastAction() {\n    let id = \"\";\n    let roomId = appData.matrixClient.currentRoomId;\n    let userId = appData.matrixClient.client.getUserId();\n    let sortedEvents = appData.objectStore.allSorted();\n    for (let i = sortedEvents.length - 1; (id === \"\" && i >= 0); i--) {\n        let event = sortedEvents[i];\n        console.log(\"looping through events to find the one to redact\");\n        if (isBoardObjectEvent(event.type) && event.sender == userId) {\n            id = event.event_id;\n            break;\n        }\n    }\n    appData.matrixClient.client.redactEvent(roomId, id).then(t => {\n        console.log(\"redacted: \", t);\n    });\n}\nfunction sendRandomText(client, room) {\n    textList = [\"hallo du\", \"noch nen test string\", \"affe\", \"haus is gross\", \"wie gehts\"];\n    text = textList[Math.floor(Math.random() * textList.length)];\n    const content = {\n        \"body\": text,\n        \"msgtype\": \"m.text\"\n    };\n    client.sendEvent(room, \"m.room.message\", content, \"\", (err, res) => {\n        console.log(err);\n    });\n}\nfunction sendCustomEvent(client, room) {\n    console.log(\"try to send custom event: ...\")\n    const content = {\n        \"version\": 2,\n        \"svg\": \"none\",\n        \"objtype\": \"p.path\",\n        \"objpos\": \"100 100\",\n        \"objcolor\": \"#000\",\n        \"closed\": true,\n        \"objFillColor\": '#ff000030',\n        \"strokeWidth\": 3,\n        \"path\": \"0 0 0 0 0 0 0 100 0 20 0 0 100 100 0 0 0 0 0 100 0 0 0 0 \",\n    };\n    client.sendEvent(room, BoardEvent.BOARD_OBJECT_EVENT_NAME, content, \"\", (err, res) => {\n        console.log(err);\n    });\n}\nfunction sendRandomPath(client, room) {\n    console.log(\"send random path: ...\")\n\n    const content = {\n        \"svg\": \"none\",\n        \"objtype\": \"p.path\",\n        \"objpos\": Math.floor(Math.random() * 80) + \" \" + Math.floor(Math.random() * 80),\n        \"objcolor\": \"#\" + [\"F55\", \"5F5\", \"55F\"][Math.floor(Math.random() * 3)],\n        \"path\": randomPath(),\n    };\n    client.sendEvent(room, BoardEvent.BOARD_OBJECT_EVENT_NAME, content, \"\", (err, res) => {\n        console.log(err);\n    });\n}\nfunction sendRandomWalk(client, room) {\n    console.log(\"send random path: ...\")\n\n    const content = {\n        \"svg\": \"none\",\n        \"objtype\": \"p.path\",\n        \"objpos\": Math.floor(100 + Math.random() * 80) + \" \" + Math.floor(100 + Math.random() * 80),\n        \"objcolor\": \"#\" + [\"F55\", \"5F5\", \"55F\"][Math.floor(Math.random() * 3)],\n        \"path\": randomStroke(),\n    };\n    client.sendEvent(room, BoardEvent.BOARD_OBJECT_EVENT_NAME, content, \"\", (err, res) => {\n        console.log(err);\n    });\n}\nfunction randomPath() {\n    var path = \"\"\n    for (let i = 0; i < Math.floor(Math.random() * 50); i++) {\n        path += i * 0.1 + \" \" + Math.floor(Math.random() * 40) + \" \" + Math.floor(Math.random() * 40) + \" \" + Math.floor(Math.random() * 6) + \" \"\n    }\n    return path;\n}\nfunction randomWalk() {\n    var walk = \"\";\n    var width = 0.1;\n    var len = Math.floor(Math.random() * 50);\n    var pos = [0, 0];\n    for (let i = 0; i < len; i++) {\n        var widthdiff = Math.random() * 0.2;\n        width += Math.min(i < len / 2 ? widthdiff : -widthdiff, 3)\n        pos = [pos[0] + Math.random() * 5 - 2.5, pos[1] + Math.random() * 5 - 2.5]\n        walk += i * 0.1 + \" \" + pos[0] + \" \" + pos[1] + \" \" + width + \" \";\n    }\n    return walk;\n}\nfunction randomStroke() {\n    var walk = \"\";\n    var width = 0.1;\n    var len = Math.floor(Math.random() * 200) + 80;\n    var pos = [0, 0];\n    var angle = 0;\n    var v_a = 0.2\n    for (let i = 0; i < len; i++) {\n        angle += v_a + 3 * Math.random() * v_a;\n        if (Math.random() < 0.07) {\n            v_a = -v_a;\n        }\n        var widthdiff = 0.1;\n        width += (i > (len - 20) || i < 20) ? -widthdiff * Math.sign(i - len / 2) : 0;\n        // width = Math.sign(width) * Math.min(Math.abs(width),8);\n        stepdist = 4 + Math.random() * 5;\n        console.log(width)\n        pos = [pos[0] + stepdist * Math.sin(angle), pos[1] + stepdist * Math.cos(angle)];\n        walk += i * 0.1 + \" \" + pos[0] + \" \" + pos[1] + \" \" + width + \" \";\n    }\n    return walk;\n}\n\nfunction formSubmit(e) {\n    e.preventDefault();\n    console.log('onsub');\n    return false;\n}\n\nfunction lastEvent() {\n    let lastEvent = null;\n    // let room = client.getRoom(roomId);\n    let userId = appData.matrixClient.client.getUserId();\n    let sortedEvents = appData.objectStore.allSorted();\n    for (let i = sortedEvents.length - 1; i >= 0; i--) {\n        let event = sortedEvents[i];\n        console.log(\"looping through events to find the one to redact\");\n        if (isBoardObjectEvent(event.type) && event.sender == userId) {\n            lastEvent = event;\n            break;\n        }\n    }\n    return lastEvent;\n}\nfunction replaceEvent(idToReplace, newContent) {\n    appData.matrixClient.client.sendEvent(appData.matrixClient.currentRoomId, BoardEvent.BOARD_OBJECT_EVENT_NAME, newContent, \"\", (err, res) => {\n        console.log(err);\n    });\n    appData.matrixClient.client.redactEvent(appData.matrixClient.currentRoomId, idToReplace).then(t => {\n        console.log(\"redacted for replace \", t);\n    });\n}\nfunction replaceLastEvent() {\n    let replaceId = lastEvent().event_id;\n    const content = {\n        \"version\": 2,\n        \"svg\": \"none\",\n        \"objtype\": \"p.path\",\n        \"objpos\": \"100 100\",\n        \"objcolor\": \"#000\",\n        \"closed\": true,\n        \"objFillColor\": '#ff000030',\n        \"strokeWidth\": 3,\n        \"path\": \"0 0 0 0 0 0 0 100 0 0 0 0 100 100 0 0 0 0 100 0 0 0 0 0\",\n    };\n    replaceEvent(replaceId, content);\n}\nfunction moveLastEvent() {\n    let ev = lastEvent();\n    let newPoint = parsePoint(ev.content.objpos).add(new paper.Point(100, 0));\n    ev.content.objpos = newPoint.x + \" \" + newPoint.y;\n    replaceEvent(ev.event_id, ev.content)\n}\nfunction toggleLeftBar() {\n    let body = document.getElementById('leftbar-expand');\n    let footer = document.getElementById('leftbar-footer')\n    if (body.getBoundingClientRect().height == 0) {\n        body.style.height = '20em';\n        footer.innerHTML = '˄'\n    } else {\n        body.style.height = '0';\n        footer.innerHTML = '˅'\n    }\n}\nfunction showAddRoomMenu() {\n    updateAddRoomList()\n    let addRoomMenu = document.getElementById(\"add-room-container\")\n    addRoomMenu.style.display = 'block'\n}\nfunction hideAddRoomMenu() {\n    let addRoomMenu = document.getElementById(\"add-room-container\")\n    addRoomMenu.style.display = 'none'\n}\n\nfunction showSettingsMenu() {\n    let settingsMenu = document.getElementById(\"settings-container\")\n    let roomId = document.getElementById('room-menu-room-id')\n    let room = appData.matrixClient.client.getRoom(appData.matrixClient.currentRoomId);\n\n    roomId.innerHTML = room.roomId\n    settingsMenu.style.display = 'block'\n}\nfunction hideSettingsMenu() {\n    let settingsMenu = document.getElementById(\"settings-container\")\n    settingsMenu.style.display = 'none'\n}","\nimport init_input from './input.js'\nimport ObjectStore from './sturctures/object-store'\nimport MatrixBackend from './backend/matrix.js';\nimport PaperCanvas from './paper-canvas'\nimport { init_color_picker } from \"./color-picker\";\nimport init_tool_wheel from \"./tools/tool-wheel\";\nimport init_line_style_selector from \"./tools/line-style-selector\";\nimport \"./components/login-container\";\nimport { isBoardRoom } from './backend/filter';\nimport * as BoardEvent from './backend/board-event-consts';\nimport './actions'\n\nwindow.appData = {\n    matrixClient: new MatrixBackend(),\n    objectStore: new ObjectStore(),\n    drawingCanvas: new PaperCanvas()\n}\n\nwindow.onload = function () {\n    appData.drawingCanvas.init();\n    init_input(document.getElementById(appData.drawingCanvas.css_id));\n    init_color_picker();\n    init_tool_wheel();\n    init_line_style_selector();\n\n    window.actions.updateRoomList = ()=>{updateRoomList()};\n    window.actions.updateAddRoomList = updateAddRoomList;\n}\nexport function updateRoomList() {\n    let roomTree = appData.matrixClient.updateRoomTree()\n    let leftbarBody = document.getElementById(\"leftbar-body\")\n    leftbarBody.innerHTML = ''\n    for (let noteb of Object.keys(roomTree.notebooks)) {\n        let notebookRoom = appData.matrixClient.client.getRoom(noteb)\n        leftbarBody.appendChild(createNotebook(notebookRoom.name, roomTree.notebooks[noteb]))\n    }\n    for (let whiteboard of roomTree.whiteboards) {\n        leftbarBody.appendChild(createDOMWhiteboard(whiteboard, '#eee'))\n    }\n    // let id = room.roomId;\n    // var roomButton = document.createElement(\"div\");\n    // console.log(id)\n    // roomButton.onclick = function (a) { console.log(a); loadRoom(id); };\n    // roomButton.classList.add(\"room-button\");\n    // var roomText = document.createElement(\"p\");\n    // roomText.innerText = visibleRooms[r].name;\n    // roomButton.appendChild(roomText);\n    // leftbarBody.insertBefore(roomButton, leftbarBody.firstChild);\n}\nfunction createNotebook(name, whiteboards) {\n    let notebook = document.createElement(\"div\")\n    let header = document.createElement(\"div\")\n    let list = document.createElement(\"div\")\n\n    header.innerHTML = name;\n    header.classList.add(\"notebook-header\");\n    let color = Color.random().toCSS()\n    header.style.borderLeftColor = color;\n\n    function getExpandHeight(list) {\n        let height = 0\n        for (let l of list.children) {\n            height += l.getBoundingClientRect().height;\n        }\n        return height;\n    }\n    header.onclick = function (a) {\n        if (list.style.height == \"\") { list.style.height = getExpandHeight(list) }\n        if (list.getBoundingClientRect().height != 0) { list.style.height = 0 }\n        else { list.style.height = getExpandHeight(list) }\n    };\n    notebook.appendChild(header);\n\n    for (let id of whiteboards) {\n        list.appendChild(createDOMWhiteboard(id, color))\n    }\n    list.classList.add(\"notebook-list\");\n    // list.style.height = getExpandHeight(list);\n    notebook.appendChild(list);\n\n    return notebook;\n}\nfunction createDOMWhiteboard(id, color) {\n    let whiteboardButton = document.createElement(\"button\")\n    let room = appData.matrixClient.client.getRoom(id);\n    whiteboardButton.onclick = function (a) { console.log(a); loadRoom(id); };\n    whiteboardButton.classList.add(\"room-button\");\n    whiteboardButton.style.borderLeftColor = color;\n    whiteboardButton.innerHTML = room.name + \"<br><span style='font-size:0.5em;color:#000'>\" + room.roomId + \"</span>\";\n    return whiteboardButton;\n}\nexport async function updateAddRoomList() {\n    let visibleRooms = appData.matrixClient.client.getVisibleRooms();\n    let addRoomBody = document.getElementById(\"add-room-list\");\n    addRoomBody.innerHTML = \"\"\n    for (let r of visibleRooms) {\n        // let room = visibleRooms[r];\n        console.log(Array.from(r.currentState.events.keys()))\n        if (r.currentState.events.has('m.space.child')\n            || isBoardRoom(r.currentState.events)) {\n            continue // only show rooms which are no spaces and are not already a whiteboard\n        }\n        let id = r.roomId;\n        var roomButton = document.createElement(\"div\");\n        roomButton.onclick = async function (a) {\n            console.log(a);\n            a.currentTarget.style.backgroundColor = '#5e5'\n            let room = await appData.matrixClient.makeWhiteboardFromRoom(id);\n            updateAddRoomList();\n            updateRoomList();\n            actions.hideAddRoomMenu();\n        };\n        roomButton.classList.add(\"room-button\");\n        var roomText = document.createElement(\"p\");\n        roomText.innerText = r.name;\n        roomButton.appendChild(roomText);\n        addRoomBody.insertBefore(roomButton, addRoomBody.firstChild);\n    }\n}\nexport function showLoading(msg) {\n    let loading = document.getElementById(\"loading\");\n    loading.style.display = \"block\";\n    let span = document.getElementById(\"loading-span\");\n    span.innerHTML = msg\n}\nexport function hideLoading() {\n    let loading = document.getElementById(\"loading\");\n    loading.style.display = \"none\";\n}\n\n// function cancelRoomLoading() {\n//     return new Promise((resolve, reject) => {\n//         resolve();\n//     });\n// }\nasync function loadRoom(roomId, scrollback_count = -1, allMessages = true) {\n    let drawC = appData.drawingCanvas;\n    console.log(drawC);\n    drawC.clear();\n    drawC.resetOffset();\n    drawC.resetZoom();\n    drawC.setZoom(0.5)\n    showLoading(\"switching Room to: \" + appData.matrixClient.currentRoomId);\n    console.log(\"switching Room to: \" + appData.matrixClient.currentRoomId);\n    document.getElementById('leftbar').classList.remove('no-room-selected');\n    appData.objectStore.addRoom(roomId);\n    appData.matrixClient.currentRoomId = roomId;\n    let s_back = scrollback_count;\n    if (scrollback_count == -1) {\n        if (Object.keys(appData.objectStore.all()).length == 0) { s_back = 300; }\n        else { s_back = 0; }\n    }\n    let room = appData.matrixClient.client.getRoom(roomId);\n    let settings = room.currentState.events.get(BoardEvent.BOARD_ROOM_STATE_NAME);\n    if (settings && settings.has(\"colorpalette\")) {\n        SetColorPalette(settings.get(\"colorpalette\"))\n    }\n    showLoading(\"load room history\");\n    const dateOptions = { year: 'numeric', month: 'numeric', day: 'numeric', hour: 'numeric' };\n    let scrollBackToken = true\n    let currentScrollbackDate = new Date()\n    let nowDate = new Date();\n    let createDate = new Date(room.currentState.getStateEvents('m.room.create', \"\").event.origin_server_ts);\n    let totalLoaded = 0\n    while (scrollBackToken) {\n        let percent = 1 - ((currentScrollbackDate - createDate) / (nowDate - createDate))\n        let roomLoaded = await appData.matrixClient.scrollback(appData.matrixClient.currentRoomId, s_back, \"Loaded: \" + Math.floor(percent * 100) + \"% (elements: \" + totalLoaded + \")</br> <span style='font-size:10px'>to Date: \" + currentScrollbackDate.toLocaleDateString('de-DE', dateOptions) + \"  Target: \" + createDate.toLocaleDateString('de-DE', dateOptions) + \"</span>\");\n        drawC.updateDisplay_DEPRECATED();\n        currentScrollbackDate = new Date(roomLoaded.timeline[0].event.origin_server_ts);\n        totalLoaded += s_back;\n        scrollBackToken = room.oldState.paginationToken;\n        if (!allMessages) { break; }\n    }\n    drawC.reload();\n    drawC.updateDisplay_DEPRECATED();\n}\n\n\n","import * as sdk from \"matrix-js-sdk\";\nimport { showLoading, hideLoading, updateRoomList } from \"../main\";\nimport NotebookTree from '../sturctures/notebook-tree'\nimport { isBoardCommitEvent, isBoardObjectEvent, isBoardRoom } from \"./filter\";\nimport { setAlpha } from \"../helper\";\nimport * as BoardEvent from './board-event-consts'\nexport default class MatrixBackend {\n    constructor() {\n        this.client = null\n        this.currentRoomId = null\n    }\n\n    updateRoomTree() {\n        let roomTree = new NotebookTree();\n        let dateNow = Date.now()\n        console.log(\"startGettingVisibleRooms\")\n        // return new Promise( (resolve, reject) {\n        let visibleRooms = this.client.getRooms();\n        console.log(\"got all visible rooms\" + (Date.now() - dateNow))\n        let spaces = visibleRooms.filter(r => r.currentState.events.has('m.space.child'))\n\n        for (let room of visibleRooms) {\n            // console.log(Array.from(room.currentState.events.keys()))\n            if (!isBoardRoom(room.currentState.events)) {\n                continue // only show rooms which are marked as whitebaord rooms\n            }\n            let found = spaces.find(spaceRoom => spaceRoom.currentState.events.get('m.space.child').has(room.roomId))\n            if (found) {\n                if (found.roomId in roomTree.notebooks) {\n                    roomTree.notebooks[found.roomId].push(room.roomId)\n                } else {\n                    roomTree.notebooks[found.roomId] = [room.roomId]\n                }\n                console.log(\"whiteboard is in space!: \", found)\n            } else {\n                roomTree.whiteboards.push(room.roomId)\n            }\n        }\n        return roomTree;\n    }\n\n    async createWhiteboard(visibility, whiteboardName) {\n        let roomOpt = {\n            // room_alias_name\n            visibility: visibility,\n            invite: [],\n            name: whiteboardName == \"\" ? \"unnamed Whiteboard\" : whiteboardName,\n        }\n        showLoading(\"Creating whiteboard with Name: \" + whiteboardName)\n        let roomCreateData = await appData.matrixClient.client.createRoom(roomOpt);\n        hideLoading();\n        appData.matrixClient.makeWhiteboardFromRoom.bind(appData.matrixClient);\n        return appData.matrixClient.makeWhiteboardFromRoom(roomCreateData.room_id);\n    }\n    async makeWhiteboardFromRoom(roomId) {\n        let content = {}\n        let client = appData.matrixClient.client;\n        let stateId = await client.sendStateEvent(roomId, BoardEvent.BOARD_ROOM_STATE_NAME, content, \"\")\n        showLoading(\"make Room \" + client.getRoom(roomId).name + \"a whiteboard\")\n        let prom = new Promise(function (resolve, reject) {\n            let listenerFunc = function (msg, state, prevEvent) {\n                if (msg.event.event_id == stateId.event_id) {\n                    client.removeListener(\"RoomState.events\", listenerFunc)\n                    resolve()\n                    hideLoading()\n                }\n            }\n            client.on(\"RoomState.events\", listenerFunc);\n        })\n        return prom;\n    }\n\n    async login(username, password, baseUrl, loginCallback) {\n        showLoading(\"login with: \" + username + \" on server: \" + baseUrl);\n        this.client = sdk.createClient({\n            baseUrl: baseUrl\n        });\n        appData.matrixClient = this;\n        window.actions.createWhiteboard = this.createWhiteboard;\n        window.actions.scrollback = this.scrollback;\n        this.setupClientConnections();\n        let registeredResult = await this.client.loginWithPassword(username, password, function (err) {\n            if (err instanceof Error) {\n                showLoading(err.message)\n                return;\n            } else {\n                loginCallback();\n            }\n        })\n        console.log(registeredResult);\n        document.getElementById(\"userIdLabel\").innerHTML = registeredResult.user_id;\n        // document.getElementById(\"userIdLabel\").innerHTML = registeredResult.user_id;\n        showLoading(\"start client\");\n        let startedResult = await this.client.startClient({ initialSyncLimit: 0, lazyLoadMembers: true });\n        showLoading(\"initial sync\");\n    }\n\n    setupClientConnections() {\n        this.client.on(\"sync\", function (state, prevState, data) {\n            switch (state) {\n                case \"ERROR\":\n                    // update UI to say \"Connection Lost\"\n                    break;\n                case \"SYNCING\":\n                    // update UI to remove any \"Connection Lost\" message\n                    break;\n                case \"PREPARED\":\n                    // the client instance is ready to be queried.\n                    updateRoomList()\n                    showLoading(\"Select a whiteboard or create a new one\")\n                    break;\n            }\n        });\n        this.client.on(\"Room.localEchoUpdated\", function (msg, room, oldId, newStatus) {\n            if (isBoardObjectEvent(msg.getType()) && msg.status === \"sent\") {\n\n                let item = project.getItem({ class: \"Path\", match: function (item) { return item.data.id == oldId } })\n                if (item) {\n                    item.data.id = msg.event.event_id\n                }\n                appData.objectStore.add(msg.event);\n            }\n        })\n        // var replacedEvents = new Set();\n        this.client.on(\"Room.timeline\", function (msg, room, toStartOfTimeline) {\n            if (msg.isRedacted()) {\n                console.log(\"skipped redacted evpped redacted event\")\n                return;\n            }\n            if (isBoardObjectEvent(msg.getType())) {\n                let animated = Date.now() - msg.getDate().getTime() < 200000;\n                appData.drawingCanvas.drawEvent(msg.event, animated);\n\n                if (msg.status == null) {\n                    //event is not sending but loaded from scrollback\n                    appData.objectStore.add(msg.event);\n                }\n            }\n            else if (isBoardCommitEvent(msg.getType())) {\n                console.log(\"Commit Event\", msg.event)\n            }\n            else if (msg.getType() == \"m.room.redaction\") {\n                appData.objectStore.redactById(msg.event.redacts, msg.event.room_id);\n            }\n            // if (msg.getType() !== \"m.room.message\") {\n            //     return;\n            // }\n        });\n    }\n\n    scrollback(roomId, scrollback_count = 200, loadingMsg = null) {\n        console.log(\"load scrollback for: \" + roomId);\n        console.log(\"load scrollback with element count: \" + scrollback_count);\n        if (loadingMsg) { showLoading(loadingMsg); } else {\n            showLoading(\"load \" + scrollback_count + \" elements from message history\");\n        }\n        let client = this.client;\n        let curRoomId = this.currentRoomId;\n        return new Promise(function (resolve, reject) {\n            if (scrollback_count == 0) {\n                hideLoading();\n                resolve(client.getRoom(curRoomId));\n            }\n            client.scrollback(client.getRoom(roomId), scrollback_count)\n                .then((room) => {\n                    console.log(\"scrollback loaded\");\n                    hideLoading();\n                    resolve(room);\n                });\n        });\n    }\n\n\n    // Sending\n    sendPath(paths, color, fillColor) {\n        let precision = 2;\n        let pathsObjArr = paths.map((p) => {\n            let pZeroPos = p.clone();\n            pZeroPos.position = pZeroPos.position.subtract(pZeroPos.bounds.topLeft);\n            let pathObj = {\n                \"segments\": pZeroPos.segments.map((s) => [s.point.x, s.point.y, s.handleIn.x, s.handleIn.y, s.handleOut.x, s.handleOut.y].map((v) => v.toFixed(precision)).join(\" \")),\n                \"closed\": pZeroPos.closed,\n                \"fillColor\": pZeroPos.fillColor ? setAlpha(pZeroPos.fillColor.toCSS(true), pZeroPos.fillColor.alpha) : null,\n                \"strokeColor\": pZeroPos.strokeColor ? setAlpha(pZeroPos.strokeColor.toCSS(true), pZeroPos.strokeColor.alpha) : null,\n                \"strokeWidth\": pZeroPos.strokeWidth,\n                \"position\": {\n                    \"x\": p.bounds.topLeft.x.toFixed(precision),\n                    \"y\": p.bounds.topLeft.y.toFixed(precision)\n                }\n            }\n\n            pZeroPos.remove()\n            return pathObj;\n        })\n        const content = {\n            \"version\": 3,\n            \"objtype\": \"path\",\n            \"paths\": pathsObjArr,\n        };\n        appData.matrixClient.sendBoardObjectEvent(content)\n    }\n    sendBoardObjectEvent(content) {\n        appData.matrixClient.client.sendEvent(appData.matrixClient.currentRoomId, BoardEvent.BOARD_OBJECT_EVENT_NAME, content, \"\", (err, res) => {\n            console.log(err);\n        });\n    }\n}","// import { currentRoomId } from \"../main\";\nexport default class ObjectStore {\n    constructor() {\n        // this.redacted = new Set();\n        this.data = {\n            \"exampleroom\": {\n                \"redacted\": new Set(),\n                \"all\": [],\n                \"allDict\": {},\n                \"user\": [],\n                \"chunk\": [],\n            }\n        }\n    }\n    currentRoom() {\n        return this.data[appData.matrixClient.currentRoomId]\n    }\n    hasRoom(roomId) {\n        return roomId in this.data;\n    }\n    addRoom(roomId) {\n        if (this.hasRoom(roomId)) {\n            console.log(\"room already exists\")\n        }\n        else {\n            console.log(\"add room \" + roomId + \"to store\");\n            this.data[roomId] = {\n                \"redacted\": new Set(),\n                \"all\": [],\n                \"allDict\": {},\n                \"user\": {},\n                \"chunk\": [],\n            }\n        }\n    }\n    // addToCurrent(obj) {\n    //     if (!this.currentRoom().redacted.has(obj.event_id)) {\n    //         this.currentRoom().all.push(obj);\n    //     }\n    // }\n    add(obj) {\n        if (!obj.room_id in this.data) {\n            this.addRoom(obj.room_id);\n        }\n        let room = this.data[obj.room_id];\n        // console.log(\"adding obj that already exists: \", room.all.some(el => el.event_id == obj.event_id));\n        room.allDict[obj.event_id] = obj;\n        // if (!room.redacted.has(obj.event_id)) {\n        // room.all.push(obj);\n        // }\n    }\n    allSorted() {\n        if (appData.matrixClient.currentRoomId in this.data) {\n            let begin_sort = Date.now();\n            let dic = this.currentRoom().allDict;\n            let allList = Object.keys(dic).map(key => dic[key]);\n            allList.sort(function (first, second) {\n                return first.origin_server_ts - second.origin_server_ts;\n            });\n            console.log(\"sorted all events: \", Date.now() - begin_sort, \"ms\")\n            return allList;\n            return this.currentRoom().all;\n        } else {\n            // If there is not current room set, the default behaviour is en empty list -> canvas gets cleared\n            return []\n        }\n    }\n    all() {\n        if (appData.matrixClient.currentRoomId in this.data) {\n            return this.currentRoom().allDict;\n        } else {\n            // If there is not current room set, the default behaviour is en empty list -> canvas gets cleared\n            return {}\n        }\n    }\n    getById(id) {\n        let found = Object.values(this.all()).find(el => el.event_id == id);\n        return found;\n    }\n    // redactByIdInCurrent(id, remove = true) {\n    //     this.currentRoom().redacted.add(id);\n    //     if (remove) {\n    //         this.currentRoom().all = this.currentRoom().all.filter(e => e.event_id !== id);\n    //     }\n    // }\n    redactById(id, roomId, remove = true) {\n        if (!this.hasRoom(roomId)) { this.addRoom(roomId) }\n        let room = this.data[roomId];\n        // room.redacted.add(id);\n        if (remove) {\n            if (id in room.allDict) {\n                delete room.allDict[id];\n                let item = paper.project.getItem({ class: \"Path\", match: function (item) { return item.data.id == id } })\n                if (item) { item.remove(); } else { console.log(\"could not find item for id: \", id) }\n            } else {\n                console.log(\"unecassary redact called for id: \", id)\n            }\n        }\n    }\n    // redact_and_remove_by_id(id){\n    //     this.redacted.add(id);\n    //     this.objects[\"all\"] = this.objects[\"all\"].filter(e => e.event_id !== id);\n    // }\n    // all_region(x,y,width,height){\n    //     //TODO\n    //     var ret = [];\n    //     this.objects[\"all\"].forEach(obj => {\n    //         pos = [obj.objpos.slice(\" \").map(x => {return parseInt(x)})];\n    //         size = [obj.objsize.slice(\" \").map(x => {return parseInt(x)})];\n    //         if obj.\n    //         ret.push()\n    //     });\n    // }\n}","import { Point } from 'paper'\nimport { tools, activeTool } from '../input';\nimport { setActiveTool } from '../input';\nimport { mousePathToString, paperPathToString, pathPosSizeCorrection, setAlpha } from \"../helper\";\n\nexport default function init_tool_wheel() {\n  let wheelContainer = document.getElementById(\"tool-wheel\");\n  let colorPickerCanvas = document.getElementById('color-picker-canvas');\n  let boundingrect = colorPickerCanvas.getBoundingClientRect()\n  let center = new Point(boundingrect.width, boundingrect.height)\n  // center = new Point(208, 208);\n  center = center.multiply(0.5);\n  let children = document.querySelectorAll(\".tool-elements\");\n  // let buttons = document.querySelectorAll(\"#tool-wheel button\");\n  let settingsButton = document.getElementById(\"settings-button\");\n  settingsButton.style.left = center.x\n  settingsButton.style.bottom = center.y\n  let rad = center.x + 15;\n  let offset = -Math.PI / 10;// -Math.PI / 4;\n  for (let i = 0; i < children.length; i++) {\n    // all units in em\n    console.log(children[i].tagName);\n    let child = children[i];\n    let angle = i * Math.PI / 7 + offset;\n    let pos = new Point(Math.sin(angle) * rad, Math.cos(angle) * rad);\n    child.style.left = center.x + pos.x;\n    child.style.bottom = center.y + pos.y;\n  }\n  for (let b of children) {\n    if (!(b.id in tools)) { continue }\n    b.onclick = function (buttonEv) {\n      for (let btn of children) {\n        btn.classList.remove('active');\n      }\n      activeTool.deactivate()\n      setActiveTool(b.id);\n      activeTool.activate()\n      b.classList.add('active');\n\n    }\n    if (activeTool == tools[b.id]) {\n      b.classList.add('active');\n    }\n  }\n}"],"names":["BOARD_OBJECT_EVENT_NAME","BOARD_ROOM_STATE_NAME","isBoardObjectEvent","type","isBoardRoom","events","has","dist","p","q","Math","sqrt","x","y","parsePoint","string","arr","split","paper","Point","parseFloat","setAlpha","color","opacity","_opStr","round","min","max","toString","toUpperCase","length","PaperCanvas","constructor","this","css_id","displayPaths","toolLayer","drawLayer","canvas","drawEvent","event","animated","drawC","appData","drawingCanvas","V1","content","objtype","points","p_path","objpos","offset","returnval","i","time","lineWidth","push","parsePath","path","pos","size","objsize","objcolor","asyncAddPathV1","drawBoundingBox","addPathV1","event_id","updateDisplay_DEPRECATED","version","segments","filter","e","seg","Segment","parseBezierPath","strokeWidth","closed","fillColor","objFillColor","asyncAddPathV2","addPathV2","V2","pathData","paths","asyncAddPathV3","addPathV3","V3","activateToolLayer","activate","activateDrawLayer","init","document","getElementById","setup","install","window","project","activeLayer","Layer","offset_delta","view","center","subtract","resetOffset","setOffset","getZoom","zoom","factor","zoomOrigin","scale","zoomOriProj","viewToProject","setZoom","currentViewCenter","resetZoom","console","log","id","dashArray","tween","dashOffset","then","pdat","l","map","s","Path","strokeColor","position","add","strokeCap","data","moveTo","lineTo","dispPath","clearDisplayPaths","forEach","remove","clear","layers","removeChildren","box","reload","starttime","Date","now","objectStore","allSorted","obj","getTransformedPointer","_tool_stroke_width_index","GetToolStrokeWidthIndex","colorPickerSvg","GetPickerColor","getColor","toCSS","ColorPicker","colors","darkColors","c","multiply","outline","colorPaths","selectedColor","COLOR_PICKER_BORDER","innerCircle","middleCircle","redraw","cent","divide","radi","width","circleBg","shadowBlur","shadowColor","create_segment_ring","circleInner","setColorPalette","palette","concat","innerRad","outerRad","index","count","PI","deg","deg2","create_segment","onMouseDown","selectColor","startDeg","endDeg","getPointFromDeg","rad","sin","cos","middleDeg","arcTo","closePath","index_arr","clone","bringToFront","ToolPen","marker","isMarker","mouse_path","mouse_path_last_time","last_pos","tool_canceled","strokeWidthOptions","previewItem","previewPaths","previewPathTween","getStrokeWidth","getStrokeColor","tooldown","proX","proY","pressure","mouse_path_start_time","visible","prev","colorAlpha","Color","alpha","toolmove","time_delta","currentPos","currentPosPoint","smooth","toolpreviewmove","Circle","applyMatrix","scaling","toolup","hasRoom","matrixClient","currentRoomId","paper_mouse_path","simplify","sendPath","toolcancel","deactivate","tools","removedElementsArray","idsToDelete","addItemsFromPoint","testPoint","hitOptions","stroke","tolerance","match","hitRes","item","hitResult","hitTest","getById","sender","client","getUserId","markedForDeletion","redactEvent","t","itemId","bounds","w","canvas_line","pt","lastSegment","point","canvas_rect","Rectangle","activeTool","over_handler","enter_handler","touchesCache","touchesCacheBegin","touchZoomCache","touchPanCache","DOMPoint","handleTouchType","NotebookTree","notebooks","whiteboards","loginContainerTemplate","createElement","innerHTML","LoginContainer","HTMLElement","super","checkUsername","username","RegExp","test","serverDomain","showLoading","AutoDiscovery","clientConf","hideLoading","baseUrl","base_url","shadowRoot","querySelector","value","hide","style","display","loginClicked","pwd","checkpwd","checkServerUrl","login","connectedCallback","attachShadow","mode","onclick","ev","onchange","el","target","addEventListener","key","preventDefault","click","appendChild","lastEvent","userId","sortedEvents","replaceEvent","idToReplace","newContent","sendEvent","err","res","updateRoomList","roomTree","updateRoomTree","leftbarBody","noteb","Object","keys","notebookRoom","getRoom","createNotebook","name","whiteboard","createDOMWhiteboard","notebook","header","list","classList","random","getExpandHeight","height","children","getBoundingClientRect","borderLeftColor","a","whiteboardButton","room","async","roomId","scrollback_count","allMessages","addRoom","s_back","all","settings","currentState","get","SetColorPalette","dateOptions","year","month","day","hour","scrollBackToken","currentScrollbackDate","nowDate","createDate","getStateEvents","origin_server_ts","totalLoaded","percent","roomLoaded","scrollback","floor","toLocaleDateString","timeline","oldState","paginationToken","loadRoom","updateAddRoomList","visibleRooms","getVisibleRooms","addRoomBody","r","Array","from","roomButton","currentTarget","backgroundColor","makeWhiteboardFromRoom","actions","hideAddRoomMenu","roomText","innerText","insertBefore","firstChild","msg","customElements","define","redactLastAction","formSubmit","replaceLastEvent","moveLastEvent","newPoint","showAddRoomMenu","showSettingsMenu","settingsMenu","hideSettingsMenu","toggleLeftBar","body","footer","dateNow","getRooms","spaces","found","find","spaceRoom","visibility","whiteboardName","roomOpt","invite","roomCreateData","createRoom","bind","room_id","stateId","sendStateEvent","Promise","resolve","reject","listenerFunc","state","prevEvent","removeListener","on","password","loginCallback","createWhiteboard","setupClientConnections","registeredResult","loginWithPassword","Error","message","user_id","startClient","initialSyncLimit","lazyLoadMembers","prevState","oldId","newStatus","getType","status","getItem","class","toStartOfTimeline","isRedacted","getDate","getTime","redactById","redacts","loadingMsg","curRoomId","pZeroPos","topLeft","pathObj","handleIn","handleOut","v","toFixed","join","sendBoardObjectEvent","Set","currentRoom","allDict","begin_sort","dic","allList","sort","first","second","values","onload","element","onpointerdown","project_pt","offsetX","offsetY","pointerType","onpointermove","buttons","findIndex","pointerId","cx","cy","canvasZoom","start1","clientX","clientY","start2","current1","current2","distStart","distCurrent","currentCenter","startCenter","panDistDelta","pinchDistDelta","abs","currentZoomFactor","offsetDiff","handlePanZoom","movementX","movementY","onpointerup","cache_event","onwheel","ctrlKey","wheelDeltaY","scroll_speed","wheelDeltaX","onpointerover","onpointerenter","passive","boundingrect","querySelectorAll","settingsButton","left","bottom","tagName","child","angle","b","buttonEv","btn","init_tool_wheel","updateVisiblePreviewItem","previewItems","btnEv","init_line_style_selector"],"sourceRoot":""}